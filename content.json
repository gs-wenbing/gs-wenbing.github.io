{"meta":{"title":"wenbing-blog","subtitle":"记录生活记录你","description":"生活需要笑着面对，明天会更好！","author":"gs-wenbing","url":"http://www.wblog.work","root":"/"},"pages":[{"title":"分类","date":"2019-09-20T05:17:46.000Z","updated":"2019-09-25T08:59:32.538Z","comments":false,"path":"categories/index.html","permalink":"http://www.wblog.work/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-09-20T01:21:27.000Z","updated":"2019-09-25T09:01:38.196Z","comments":false,"path":"tags/index.html","permalink":"http://www.wblog.work/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Rxjava - RxScheduler示例和详细解析","slug":"rxjava-schedul","date":"2019-09-25T03:21:27.000Z","updated":"2019-09-25T09:41:40.923Z","comments":true,"path":"rxjava-schedul/","link":"","permalink":"http://www.wblog.work/rxjava-schedul/","excerpt":"概述首先了解 Schedulers 和 Scheduler 的概念Scheduler 是负责执行任务的单元, 调度器，相当于线程控制器，RxJava 通过它来指定每一段代码应该运行在什么样的线程，而 Schedulers 是创建各种 Scheduler 的工厂，Schedulers.io()等等都返回的是 Scheduler。","text":"概述首先了解 Schedulers 和 Scheduler 的概念Scheduler 是负责执行任务的单元, 调度器，相当于线程控制器，RxJava 通过它来指定每一段代码应该运行在什么样的线程，而 Schedulers 是创建各种 Scheduler 的工厂，Schedulers.io()等等都返回的是 Scheduler。 我们可以使用使用 subscribeOn() 和 observeOn() 两个方法来对线程进行控制。比如常用的 Observable 生成发射数据流，以及 Operators 加工数据流都是在后台线程中进行，而 Observer 在前台线程中接受并相应数据。 subscribeOn() 和 observeOn() subscribeOn(): 指定 ObservableOnSubscribe#subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程，我把他叫做上游。当调用多次 subscribeOn() 时，事件产生会运行在最早的一次调用声明的线程中。当然也不是说多次的调用是完全没效果的，后面会提到。 observeOn(): 指定 Observer 所运行在的线程。或者叫做事件消费的线程，我把他叫做下游。每次调用 observeOn() 都会发生线程切换，此次调用直到下次切换线程中间的过程中的操作运行在此次调用指定的线程中。 RxJava 提供了以下这些调度器： Schedulers.single();运行在一个单独的线程，顺序执行，先进先出 Schedulers.computation();计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算；默认线程数等于处理器的数量。 不要执行阻塞、IO操作(IO操作请使用Schedulers.io()) Schedulers.io();I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程 Schedulers.trampoline();在当前线程立即执行任务，如果当前线程有任务在执行，则会将其暂停，等插入进来的任务执行完之后，再将未完成的任务接着执行 Schedulers.newThread();总是启用新线程，并在新线程执行操作 Schedulers.from(@NonNull Executor executor);使用指定的 Executor 作为调度器 AndroidSchedulers.mainThread();它指定的操作将在 Android 主线程运行 示例以下示例部分参考：https://www.jianshu.com/p/12638513424f自己再敲一遍，有助于更深层的理解 示例1 使用一次subscribeOn和一次observeOn： 123456789101112Observable .create((ObservableOnSubscribe&lt;Integer&gt;) emitter -&gt; &#123; for (int i =1;i&lt;3;i++)&#123; System.out.println(\"发射线程：\"+Thread.currentThread().getName()+\"----&gt;\"+\"发射：\"+i); Thread.sleep(1000); emitter.onNext(i); &#125; emitter.onComplete(); &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(integer -&gt; System.out.println(\"接收线程：\"+Thread.currentThread().getName()+\"----&gt;\"+\"接收：\"+integer))); 打印日志： 1234发射线程：RxCachedThreadScheduler-1----&gt;发射：1发射线程：RxCachedThreadScheduler-1----&gt;发射：2接收线程：main----&gt;接收：1接收线程：main----&gt;接收：2 可以看出 上游数据发射在 RxCachedThreadScheduler-1 中执行，也就是IO线程中执行，下游接收是在主线程main中 示例2 使用两次 subscribeOn 和一次 observeOn： 123456789101112131415161718Observable .create((ObservableOnSubscribe&lt;Integer&gt;) emitter -&gt; &#123; for (int i =1;i&lt;3;i++)&#123; System.out.println(\"发射线程：\"+Thread.currentThread().getName()+\"----&gt;\"+\"发射：\"+i); Thread.sleep(1000); emitter.onNext(i); &#125; emitter.onComplete(); &#125;) .subscribeOn(Schedulers.io()) .map(integer -&gt; &#123; System.out.println(\"处理线程：\"+Thread.currentThread().getName()+\"----&gt;\"+\"处理：\"+integer); return integer; &#125;) .subscribeOn(Schedulers.newThread())//这次设置线程没起作用 .observeOn(AndroidSchedulers.mainThread()) .subscribe(integer -&gt; System.out.println(\"接收线程：\"+Thread.currentThread().getName()+\"----&gt;\"+\"接收：\"+integer)); 打印日志： 123456发射线程：RxCachedThreadScheduler-1----&gt;发射：1处理线程：RxCachedThreadScheduler-1----&gt;处理：1接收线程：main----&gt;接收：1发射线程：RxCachedThreadScheduler-1----&gt;发射：2处理线程：RxCachedThreadScheduler-1----&gt;处理：2接收线程：main----&gt;接收：2 可以看出 数据的接收是在主线程（main）中，但是发射和处理都在 RxCachedThreadScheduler-1 中执行，也就是IO线程中执行，而我们设置的 subscribeOn(Schedulers.newThread() 没起作用 示例3使用一次 subscribeOn 和两次 observeOn： 1234567891011121314151617Observable .create((ObservableOnSubscribe&lt;Integer&gt;) emitter -&gt; &#123; for (int i =1;i&lt;3;i++)&#123; System.out.println(\"发射线程：\"+Thread.currentThread().getName()+\"----&gt;\"+\"发射：\"+i); Thread.sleep(1000); emitter.onNext(i); &#125; emitter.onComplete(); &#125;) .subscribeOn(Schedulers.io()) .observeOn(Schedulers.newThread()) .map(integer -&gt; &#123; System.out.println(\"处理线程：\"+Thread.currentThread().getName()+\"----&gt;\"+\"处理：\"+integer); return integer; &#125;) .observeOn(AndroidSchedulers.mainThread()) .subscribe(integer -&gt; System.out.println(\"接收线程：\"+Thread.currentThread().getName()+\"----&gt;\"+\"接收：\"+integer))); 打印日志： 123456发射线程：RxCachedThreadScheduler-1----&gt;发射：1发射线程：RxCachedThreadScheduler-1----&gt;发射：2处理线程：RxNewThreadScheduler-1----&gt;处理：1接收线程：main----&gt;接收：1处理线程：RxNewThreadScheduler-1----&gt;处理：2接收线程：main----&gt;接收：2 可以看出发射线程在 RxCachedThreadScheduler-1 (IO线程) 中，数据的处理在 RxNewThreadScheduler-1 (也就是Schedulers.newThread())中，数据的接收在 主线程main中。说明 Observeon 每次设置都会起作用 示例4：doOnSubscribe()/onSubscribe()，doOnNext()/onNext()，doOnComplete()/onComplete()，doOnError()/onError() 1234567891011121314151617181920212223242526272829303132333435363738394041424344System.out.println(\"当前线程----&gt;\" + Thread.currentThread().getName());mDisposables.add(Observable .create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; System.out.println(\"Observable线程----&gt;\" + Thread.currentThread().getName()); e.onNext(10); e.onComplete(); &#125; &#125;) // 从上面demo中可知 Observable 会在计算线程中执行 .subscribeOn(Schedulers.computation()) // 预测1：observeOn切换到线程，doOnSubscribe 在 NewThread-1 线程 .observeOn(Schedulers.newThread()) .doOnSubscribe(new Consumer&lt;Disposable&gt;() &#123; @Override public void accept(@NonNull Disposable disposable) throws Exception &#123; System.out.println(\"doOnSubscribe线程----&gt;\" + Thread.currentThread().getName()); &#125; &#125;) // 预测2：observeOn切换到线程，doOnNext 在 NewThread-2 线程 .observeOn(Schedulers.newThread()) .doOnNext(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; System.out.println(\"doOnNext线程----&gt;\" + Thread.currentThread().getName()); &#125; &#125;) // 预测3：observeOn切换到线程，doOnComplete 在 NewThread-3 线程 .observeOn(Schedulers.newThread()) .doOnComplete(new Action() &#123; @Override public void run() throws Exception &#123; System.out.println(\"doOnComplete线程----&gt;\" + Thread.currentThread().getName()); &#125; &#125;) // 预测4：observeOn切换到线程，subscribe 在 NewThread-4 线程 .observeOn(Schedulers.newThread()) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; System.out.println(\"subscribe线程----&gt;\" + Thread.currentThread().getName()); &#125; &#125;)); 打印日志： 123456当前线程----&gt;maindoOnSubscribe线程----&gt;mainObservable线程----&gt;RxComputationThreadPool-1doOnNext线程----&gt;RxNewThreadScheduler-2doOnComplete线程----&gt;RxNewThreadScheduler-3subscribe线程----&gt;RxNewThreadScheduler-4 可以看出我们预测2/3/4点都正确，doOnNext()、doOnComplete()、subscribe都在指定的newThread中，但是预测1却在主线程，说明 observeOn() 不能切换doOnSubscribe()。 我们再做个这样的测试，把整段代码放在新的 Thread 中执行 1234567891011121314151617181920212223242526272829303132//新建一个ThreadThread thread = new Thread()&#123; @Override public void run() &#123; System.out.println(\"当前线程----&gt;\" + Thread.currentThread().getName()); mDisposables.add(Observable .create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; System.out.println(\"Observable线程----&gt;\" + Thread.currentThread().getName()); e.onNext(10); e.onComplete(); &#125; &#125;) .subscribeOn(Schedulers.computation()) .doOnSubscribe(new Consumer&lt;Disposable&gt;() &#123; @Override public void accept(@NonNull Disposable disposable) throws Exception &#123; System.out.println(\"doOnSubscribe线程----&gt;\" + Thread.currentThread().getName()); &#125; &#125;) .observeOn(Schedulers.newThread()) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; System.out.println(\"subscribe线程----&gt;\" + Thread.currentThread().getName()); &#125; &#125;)); &#125;&#125;;//启动线程thread.start(); 输入日志： 1234当前线程----&gt;Thread-282doOnSubscribe线程----&gt;Thread-282Observable线程----&gt;RxComputationThreadPool-1subscribe线程----&gt;RxNewThreadScheduler-1 看来doOnSubscribe比较特殊，它默认运行在执行该段代码的线程中，我们再用subscribeOn() 切换了线程试试： 12345678910// 预测1、observeOn切换到线程，doOnSubscribe 在 NewThread 线程，切换无效// .observeOn(Schedulers.newThread()).doOnSubscribe(new Consumer&lt;Disposable&gt;() &#123; @Override public void accept(@NonNull Disposable disposable) throws Exception &#123; System.out.println(\"doOnSubscribe线程----&gt;\" + Thread.currentThread().getName()); &#125;&#125;)//subscribeOn 切换线程，doOnSubscribe 会不会在 io 线程呢？.subscribeOn(Schedulers.io()) 输入日志： 123456当前线程----&gt;maindoOnSubscribe线程----&gt;RxCachedThreadScheduler-1Observable线程----&gt;RxComputationThreadPool-1doOnNext线程----&gt;RxNewThreadScheduler-1doOnComplete线程----&gt;RxNewThreadScheduler-2subscribe线程----&gt;RxNewThreadScheduler-3 我们看到用 subscribeOn(Schedulers.io()) 切换到了 IO 线程 对于 doOnNext()/onNext()，doOnComplete()/onComplete()，doOnError()/onError() 几个方法 (前者是 被观察者 调用的方法，后者是 观察者 接口里面的对应方法) ，可以通过 observeOn() 进行线程的切换。 而对于 doOnSubscribe()/onSubscribe() 方法 (前者是 被观察者 调用的方法，后者是 观察者 接口里面的对应方法) 来说，如果他后面有调用 subscribeOn() 切换线程，那么它运行在切换的线程，否则他默认运行在执行该段代码的线程中 示例5 Schedulers.trampoline()： 通过上面示例我们可以发现，Observer处理数据相比于Observable发射的数据存在滞后的现象，Observable发射了两个数据，Observer才处理了一个，并不是Observable每发射一个，Observer就处理一个。 1234567891011121314151617Observable .create((ObservableOnSubscribe&lt;Integer&gt;) emitter -&gt; &#123; for (int i = 1; i &lt; 3; i++) &#123; System.out.println(\"发射线程：\" + Thread.currentThread().getName() + \"----&gt;\" + \"发射：\" + i); Thread.sleep(1000); emitter.onNext(i); &#125; emitter.onComplete(); &#125;) .subscribeOn(Schedulers.io()) .observeOn(Schedulers.trampoline()) // .subscribeOn(Schedulers.trampoline()) // .observeOn(Schedulers.trampoline()) .subscribe(integer -&gt; &#123; Thread.sleep(2000); System.out.println(\"接收线程：\" + Thread.currentThread().getName() + \"----&gt;\" + \"接收：\" + integer); &#125;) 打印日志： 1234发射线程：RxCachedThreadScheduler-1----&gt;发射：1接收线程：RxCachedThreadScheduler-1----&gt;接收：1发射线程：RxCachedThreadScheduler-1----&gt;发射：2接收线程：RxCachedThreadScheduler-1----&gt;接收：2 可以看到日志是按 发射-&gt;处理-&gt;接收 的顺序打印的，说明 Observable 在 Observer 将数据处理完之后才开始发射下一条。Schedulers.trampoline() 的作用 在当前线程（当前线程是IO线程）立即执行任务，如果当前线程有任务在执行，则会将其暂停，等插入进来的任务执行完之后，再将未完成的任务接着执行。 我们这样改下： 1234 // .subscribeOn(Schedulers.io()) // .observeOn(Schedulers.trampoline()).subscribeOn(Schedulers.trampoline()).observeOn(Schedulers.trampoline()) 打印日志： 1234发射线程：main----&gt;发射：1接收线程：main----&gt;接收：1发射线程：main----&gt;发射：2接收线程：main----&gt;接收：2 我们都注释掉： 1234 // .subscribeOn(Schedulers.io()) // .observeOn(Schedulers.trampoline())// .subscribeOn(Schedulers.trampoline())// .observeOn(Schedulers.trampoline()) 打印日志： 1234发射线程：main----&gt;发射：1接收线程：main----&gt;接收：1发射线程：main----&gt;发射：2接收线程：main----&gt;接收：2 和上面一样说明 Schedulers.trampoline() 是作用当前主线程main上，相当于不指定线程。 示例6 Schedulers.single()： 12345678910111213141516171819Observable .create((ObservableOnSubscribe&lt;Integer&gt;) emitter -&gt; &#123; for (int i = 1; i &lt; 3; i++) &#123; System.out.println(\"发射线程：\" + Thread.currentThread().getName() + \"----&gt;\" + \"发射：\" + i); Thread.sleep(1000); emitter.onNext(i); &#125; emitter.onComplete(); &#125;) .subscribeOn(Schedulers.single()) .observeOn(Schedulers.single()) .map(integer -&gt; &#123; System.out.println(\"处理线程：\" + Thread.currentThread().getName() + \"----&gt;\" + \"处理：\" + integer); return integer; &#125;) .observeOn(Schedulers.single()) .subscribe(integer -&gt; &#123; System.out.println(\"接收线程：\" + Thread.currentThread().getName() + \"----&gt;\" + \"接收：\" + integer); &#125;) 打印日志： 123456发射线程：RxSingleScheduler-1----&gt;发射：1发射线程：RxSingleScheduler-1----&gt;发射：2处理线程：RxSingleScheduler-1----&gt;处理：1处理线程：RxSingleScheduler-1----&gt;处理：2接收线程：RxSingleScheduler-1----&gt;接收：1接收线程：RxSingleScheduler-1----&gt;接收：2 通过Schedulers.single()将数据的发射，处理，接收在Schedulers.single()的线程单例中排队执行，当此线程中有任务执行时，其他任务将会按照先进先出的顺序依次执行。 下面举个完整的示例，需求是这样的： （1）在io线程请求服务器数据； （2）请求之前需要在主线程显示 Loading dialog； （3）数据返回后在 computation() 处理； （4）处理完成后在 io() 存入数据库； （5）主线程 更新UI； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Observable .create(new ObservableOnSubscribe&lt;List&lt;String&gt;&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;List&lt;String&gt;&gt; emitter) throws Exception &#123; System.out.println(\"IO线程----&gt;发起网络请求，请求服务器数据\"); // TODO: 2019/8/23 请求网络 List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i=0;i&lt;10;i++)&#123; list.add(\"数据\"+i); &#125; emitter.onNext(list); emitter.onComplete(); &#125; &#125;) .subscribeOn(Schedulers.io()) .doOnSubscribe(new Consumer&lt;Disposable&gt;() &#123; @Override public void accept(Disposable disposable) throws Exception &#123; System.out.println(\"UI主线程----&gt;显示 Loading dialog\"); &#125; &#125;) .subscribeOn(AndroidSchedulers.mainThread()) .observeOn(Schedulers.computation()) .filter(new Predicate&lt;List&lt;String&gt;&gt;() &#123; @Override public boolean test(List&lt;String&gt; list) throws Exception &#123; //list 从服务器请求的数据 System.out.println(\"计算线程处理----&gt;处理数据\"); return true; &#125; &#125;) .observeOn(Schedulers.io()) .doOnNext(new Consumer&lt;List&lt;String&gt;&gt;() &#123; @Override public void accept(List&lt;String&gt; filterList) throws Exception &#123; //filterList 处理后的数据 System.out.println(\"IO线程----&gt;存入数据库\"); &#125; &#125;) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;List&lt;String&gt;&gt;() &#123; @Override public void accept(List&lt;String&gt; list) throws Exception &#123; //str 处理之后的数据 System.out.println(\"UI主线程----&gt;显示数据更新UI\"); &#125; &#125;) 打印日志： 12345UI主线程----&gt;显示 Loading dialogIO线程----&gt;发起网络请求，请求服务器数据计算线程处理----&gt;处理数据IO线程----&gt;存入数据库UI主线程----&gt;显示数据更新UI 通过以上示例，我们可以总结subscribeOn和observeOn的用法如下: subscribeOn 用来声明上游事件发送时的所在线程，若多次设定，上游会运行在 最早 的一次调用声明的线程中。observeOn 指定下游操作所在的线程。若多次设定，每次均起作用。如若不指定下游线程，则默认在上游所在的线程中","categories":[{"name":"开发","slug":"开发","permalink":"http://www.wblog.work/categories/开发/"}],"tags":[{"name":"Rxjava","slug":"Rxjava","permalink":"http://www.wblog.work/tags/Rxjava/"}]},{"title":"【转】java反射基础学习（附demo）","slug":"reflection","date":"2019-09-20T01:21:27.000Z","updated":"2019-09-25T09:19:23.882Z","comments":true,"path":"reflection/","link":"","permalink":"http://www.wblog.work/reflection/","excerpt":"Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有的属性和方法；对于任意一个对象，都能够调用它的任何方法和属性；","text":"Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有的属性和方法；对于任意一个对象，都能够调用它的任何方法和属性； 也就是说反射机制在程序运行的过程中，能够获取任何已知名称的类的内部信息，并在执行过程中，动态生成对象实体、对fields设值、或者调用methods。 这种在程序运行过程中，动态获取类的信息以及动态调用方法的功能称为Java的反射机制。 Reflection API 简介在JDK中，主要由一下类来实现Java反射机制，这些类（出来Class）都位于java.lang.reflect包中。 类名 含义 Class 类 代表某个具体的类和接口，位于java.lang包下 Field类 代表类的成员变量（成员变量也称为类的属性） Method类 代表类或者接口上的方法 Constructor类 代表类的构造方法 Array类 提供了动态创建数组，以及访问数组的元素的静态方法 Class类Class本身就是一个类，Class是该类的名称，注意不要理解成类类型。 1public class MyTest&#123;&#125; 注意上面的class的首字母是小写的，他表示一中类类型，但是Class是一个类，相当于上面定义的MyTest类。 在Java中，每个class都有一个相应的Class对象，也就是说，当我们编写一个类，编译成.class文件后，就会产生一个Class对象，用于表达这个类的类型信息。无论某个类有多少个对象，这些对象都会对应同一个Class对象。 Class的获取方式： 使用Class类的静态方法 1Class&lt;?&gt; testClazz01 = Class.forName(\"com.zwb.MyTest\"); 使用类的.class 1Class&lt;? extends MyTest&gt; testClazz02 = MyTest.class; 使用对象的getClass()方法 12MyTest myTest = new MyTest();Class&lt;? extends MyTest&gt; testClazz03 = myTest.getClass(); Class相关的方法 获得类相关的方法 方法名 含义 asSubClass(Class clazz) 把传递的类的对象转换成代表其子类的对象 Cast 把对象转换成代表类或者接口的对象 getClassLoader() 获得类的加载器 getClasses() 返回一个数组，数组中包含该类中所有具有public属性的类和接口类的对象 getDeclaredClasses() 返回一个数组，数组中包含该类中所有类和接口类的对象 forName(String className) 根据类名返回类的对象 getName() 获得类的完整路径名字 newInstance() 创建类的实例 getPackage 获取类的包 getSimpleName 获取类的名字 getSuperclass 获取父类的名字 getInterfaces 获取当前类实现的接口 示例 获得类中构造器相关的方法 方法 含义 getConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的公有构造方法 getConstructors() 获得该类的所有公有构造方法 getDeclaredConstructors(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的构造方法 getDeclaredConstructors() 获得该类所有构造方法 示例 获得类中方法相关的方法 方法 含义 getMethod(String name, Class…&lt;?&gt; parameterTypes) 根据方法名和参数，返回一个具体的具有public属性的方法 getMethods() 返回所有具有public属性的方法数组（包括从父类继承的public方法和实现接口的public方法） getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes) 根据方法名和参数，返回一个具体的方法（不分public和非public属性） getDeclaredMethods() 返回该类中的所有的方法数组（不分public和非public属性） 示例 获得类中属性相关的方法 方法 含义 getField(String name) 根据变量名，返回一个具体的具有public属性的成员变量 getFields() 返回具有public属性的成员变量的数组 getDeclaredField(String name) 根据变量名，返回一个成员变量（不分public和非public属性） getDeclaredFields() 返回所有成员变量组成的数组（不分public和非public属性） 示例 获得类中注解相关的方法 方法 含义 getAnnotation(Class annotationClass) 返回该类中与参数类型匹配的公有注解对象 getAnnotations() 返回该类所有的公有注解对象 getDeclaredAnnotation(Class annotationClass) 返回该类中与参数类型匹配的直接修饰的所有注解对象 getDeclaredAnnotations() 返回该类所有的直接修饰的注解对象 示例 其他重要的方法 方法 含义 isAnnotation() 判断是否是注解 isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) 判断是否是指定类型的注解 isAnonymousClass() 判断是否是匿名类 isArray() 判断是否是数组类 isEnum() 判断是否是枚举类 isInstance(Object obj) 判断obj是否是该类的实例 isInterface() 判断是否是接口类 Field类Field代表类的成员变量（属性） 方法 含义 get(Object obj) 获取obj对应的属性值 set(Object obj,Object value) 设置obj对应的属性值 equals(Object obj) 判断与obj是否相等 Method类Method代表类的方法 方法 含义 invoke(Object receiver,Object… args) 传递object对象及参数调用该对象对应的方法 参数receiver指明了调用对象，参数args指明该方法所需要接收的参数。由于是运行时动态的调用类的方法，无法提前知道参数类型和返回值，所以传入和返回的都是Object比如： 1234567891011class MyTest&#123; private int testInvoke(int i)&#123; return i*10; &#125;&#125;Class&lt;?&gt; classTest = Class.forName(\"com.zwb.MyTest\");Method methodTest = MyTest.getDeclaredMethod(\"testInvoke\",int.class);methodTest.setAccessible(true);Object objectTest = classTest.newInstance();int result = (int) methodTest.invoke(objectTest,1);// result=10 说明这里主要是学习反射最基础的语法和相关的API，一些深层的知识点请自行查阅资料。以上都是参考别人总结的（绝不是copy，都是在理解的基础上一字一句自己敲的），示例是我根据相关的API自己敲的，古人云：眼过千遍不如手过一遍。如对原文作者又冒犯之处，请及时联系立删 参考：https://www.jianshu.com/p/9be58ee20deehttps://www.cnblogs.com/crazypebble/archive/2011/04/13/2014582.html","categories":[{"name":"开发","slug":"开发","permalink":"http://www.wblog.work/categories/开发/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.wblog.work/tags/Java/"}]},{"title":"【转】Java注解基础学习","slug":"annotation","date":"2019-09-20T01:21:27.000Z","updated":"2019-09-25T09:13:56.719Z","comments":true,"path":"annotation/","link":"","permalink":"http://www.wblog.work/annotation/","excerpt":"其实同class和interface一样，注解也属于一种类型。它是在Java SE 5.0版本中开始引入的概念。","text":"其实同class和interface一样，注解也属于一种类型。它是在Java SE 5.0版本中开始引入的概念。 注解的定义注解通过 @ interface 关键字进行定义。 123public @interface TestAnnotation &#123;&#125; 它的形式跟接口很类似，不过前面加了@符号。 上面的代码就创建了一个名字为TestAnnotation的注解。 可以简单理解为创建了一张名字为TestAnnotation的标签 注解的应用上面创建了一个注解，那么注解怎么使用呢？ 1234@TestAnnotationpublic class Test &#123;&#125; 创建一个类 Test，然后在类上面加上 @ TestAnnotation 就可以用。你可以简单理解为将 TestAnnotation 这个张标签贴到Test这个类上面。 不过，想要注解能够正常工作，还需介绍一下 元注解。 元注解元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其他的注解上面。 如果难于理解的话，可以这样理解。元注解就是一种标签，但是它是一张特殊的标签，它的作用和目的就是给其他普通的标签进行解释说明的。 元注解有 @Retention、 @Documented、 @Target、 @Inherited、 @Repeatable 5种。 @RetentionRetention的英文意为保留期的意思。当@Retention 引用到一个注解上的时候，它解释了这个注解的存活时间。 源码如下： 123456@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Retention &#123; RetentionPolicy value();&#125; 从源码可以看出，其有一个属性value，返回一个枚举 RetentionPolicy 类型，有3种类型： RetentionPolicy.SOURCE： 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽略。 RetentionPolicy.CLASS：注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。 RetentionPolicy.RUNTIME：注解可以保留到程序运行的时候，它会被加载进入到JVM中，所以在程序运行时可以获取到它们。 我们可以通过这样的方式类加深理解，@Retention 去给一张标签解释的时候，它指定了这张标签的时间。@Retention相当于给一张标签上面盖了一张时间戳，时间戳指明了标签张贴的时间周期。 1234@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation&#123;&#125; 上面的代码中，我们指定了TestAnnotation 可以在程序运行周期被获取到，因次它的生命周期非常长。 @Document顾名思义，这个元注解肯定和文档有关。它的作用是能够将注解中的元素包含到Javadoc中取。 @TargetTarget是目标的意思，@Target指定了注解运用的地方。也就是指明，你的注解到底是用来修饰方法的？修饰类的？还是用来修饰字段属性的。 123456@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Target &#123; ElementType[] value();&#125; 从源码中可以看出，其有一个属性value，返回一个枚举 ElementType 类型的数组，这个数组的值就代表了可以在那些场景。 1234567891011121314151617181920212223242526272829303132333435public enum ElementType &#123; /** 允许被修饰的注解作用在类、接口和枚举上 */ TYPE, /** 允许作用在属性字段上，包括enum实例 */ FIELD, /** 允许作用在方法上 */ METHOD, /** 允许作用在方法参数上 */ PARAMETER, /** 允许作用在构造器上 */ CONSTRUCTOR, /** 允许作用在局部变量上 */ LOCAL_VARIABLE, /** 允许作用在注解上(应用于另一个注解上) */ ANNOTATION_TYPE, /** 允许作用在包上 */ PACKAGE, /** * 允许作用在类型参数声明（1.8新加入） */ TYPE_PARAMETER, /** * 允许作用在类型使用声明（1.8新加入) */ TYPE_USE&#125; 例如 @Override 注解使用了@Target(ElementType.METHOD)，意味着，它只能注解方法，不能注解属性或者类，或者其他情况。当未指定Target值时，则可以用于任何元素上，多个值则使用{}包含并用 “,”隔开，比如：@Target(value={CONSTRUCTOR,FIELD,METHOD}该注解既可注解构造方法、字段和方法。 @InheritedInherited是继承的意思，其让被修饰的注解拥有被继承的能力。 一个被@Inherited注解了的注解 修饰了一个父类，如果他的子类没有被其他注解修饰，则他的子类也继承了父类的注解。 1234567891011121314151617181920212223242526/** 自定义注解*/@Inherited@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface TestAnnotation&#123;&#125;/** 父类标注 自定义注解 */@TestAnnotationpublic class Father&#123;&#125;/** 子类 */public class Son extentx Father&#123;&#125;/** 测试子类获取父类自定义注解*/public class Test&#123; public static void main(String[] args)&#123; //获取Son的class对象 Class&lt;Son&gt; sonClass = Son.class; //获取Son类上的注解TestAnnotation可以执行成功 TestAnnotation annotation = sonClass.getAnnotation(TestAnnotation.class); &#125;&#125; 注解TestAnnotation被@Inherited修饰，之后类Father被TestAnnotation注解，类Son继承了Father类，类Son也就拥有TestAnnotation这个注解。 可以这样理解： 老子非常有钱，所以人们给他贴了一张标签叫做富豪。 老子的儿子长大后，只要没和老子断绝父子关系，虽然别人没给他贴富豪的标签，但他自然也是富豪。 老子的孙子长大后，自然也是富豪。 这就是人们口中戏称的富一代，富二代，富三代。虽然叫法不同，好像好多个标签，但其实事情的本质也就是他们有一张共同的标签，也就是老子身上的那张富豪的标签。 @RepeatableRepeatable是可重复的意思，@Repeatable是Java1.8才加进来的，所有算是一个新的特效。 别这个元注解修饰的注解 可以多次修饰同一个对象，但是每次注解又代表不同的含义。比如：一个人既是程序员，又是成品经理，同时也是画家 1234567891011121314151617/** 定义一个容器注解*/@interface Persons&#123; Person[] value();&#125;/** 被Repeatable修饰的注解 */@Repeatable(Persons.class)@interface Person&#123; String role() default \"\";&#125;@Person(role=\"artist\")@Person(role=\"coder\")@Person(role=\"PM\")class SuperMan&#123; &#125; 上面的代码@Repeatable注解了Person。而@Repeatable后面括号中的类相当于一个容器注解。 什么是容器注解呢？就是存放其他注解的地方。他本身也是一个注解。 容器注解，他里面必须要有一个value的属性，注意它是数组。 如果不好理解的话，可以这样理解。Persons 是一张总的标签，上面贴满了Person这种类型但内容不一样的标签。把Person给SuperMan贴上，相当于同时给他贴上了程序员、产品经理、画家的标签。 我们可能对于@Person(role=”PM”) 括号里的内容感兴趣，他其实就是Person这个注解的role属性赋值为PM。 注解的属性注解的属性也叫做成员变量。注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。 注解本质上就是一个Annotation接口 1234567891011/** Annotatioin 接口源码*/public interface Annotation&#123; boolean equals（Object obj; int hashCode(); String toString(); Class&lt;? extends Annotation&gt; annotationType();&#125; 通过以上源码，我们知道注解本身就是Annotation接口的子接口，也就是说注解其实可以有属性和方法，但是接口的数据都是static final的，对于注解来说没有什么意义，而我们定义的接口方法就相当于是注解的属性，也就对应了前面所说的为什么注解只有属性成员变量，其实他就是接口的方法，这就为什么成员变量会有方法，不同于接口的是我们可以在注解的括号中给成员变量赋值。 123456789@Target(ElementType.TYPE)@Retention(RetentioniPolicy.RUNTIME)public @interface TestAnnotation&#123; String name() default \"zk\"; int age() default 18;&#125;@TestAnnotation(name=\"zhangke\",age=\"25\")public class Person&#123;&#125; 上面代码定义了TestAnnotation 这个注解拥有name和age两个属性。用default 指定默认值。如果有default设置了默认值时，也可以无需在TestAnnotation后面的括号中进行赋值。 123@TestAnnotation()public class Person&#123;&#125; 赋值的方式就是在注解的括号中用“,”隔开分别给对应的属性赋值。如果注解的只有一个属性时，可以直接把属性值写到括号中。 12345678@Target(ElementType.TYPE)@Retention(RetentioniPolicy.RUNTIME)public @interface TestAnnotation&#123; String name();&#125;@TestAnnotation(zhangke)public class Person&#123;&#125; 需要注意的是，在注解中定义属性时有一下几种的类型：1、基本数据类型2、String3、枚举4、注解5、类、接口6、以上类型的一维数组类型 Java 内置的注解Java内置的直接共有5个@Override：这个大家很熟悉了，让编译器检查被标记的方法，保证其重写了父类的某一个方法。此注解只能标记方法。 1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125; @Deprecated：标记某些程序元素已经过时，程序员请不要再使用了 12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)public @interface Deprecated &#123;&#125; @SuppressWarnings：阻止警告的意思。调用了被@Deprecated注解后的方法，编译器会警告提醒，但是开发者不想看到这些警告，可以使用@SuppressWarnings达到目的 12345@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings &#123; String[] value();&#125; 其内部有个String数组类型的属性，根据传入的值来取消相应的警告：deprecation：使用了不赞成使用的类或方法时的警告；unchecked：执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型;fallthrough：当 Switch 程序块直接通往下一种情况而没有 Break 时的警告;path：在类路径、源文件路径等中有不存在的路径时的警告;serial：当在可序列化的类上缺少 serialVersionUID 定义时的警告;finally：任何 finally 子句不能正常完成时的警告;all：关于以上所有情况的警告 @SafeVarargs(Java7 新增)：@SuppressWarnings可以用在各种需要取消警告的地方，而 @SafeVarargs主要用在取消参数的警告。就是说编译器如果检查到你对方法参数的操作，有可能发生问题时会给出警告，但是你很自（任）性，老子不要警告，于是你就加上了这个标签。 1234@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD&#125;)public @interface SafeVarargs &#123;&#125; @FunctionalInterface(Java8 新增)：标记型注解，告诉编译器检查被标注的接口是否是一个函数接口，即检查这个接口是否只包含一个抽象方法，只有函数接口才可以使用Lambda表达式创建实例。 如何使用注解前面我们学习了注解的基本语法，那注解具体怎么使用呢？这时候就需要用到APT（Annotation Processing Tool），访问和处理Annotation的工具，那么APT是具体怎么读取注解的属性信息的呢，那就是反射。Annotation接口是所有注解的父接口（需要通过发编译查看），在java.lang.reflect发射包下存在一个叫AnnotationElement的接口，其表示程序中可以接受注解的程序元素，比如类，方法，字段，构造方法，包等等。而Java为使用反射的主要类实现了此接口，如Class类、Field类、Method类、Constructor类等。 当我们通过反射技术获取到反射包内的那些类型的实例后，就可以通过AnnotationElement接口的API方法来获取注解信息了。 1234567891011121314151617/**是否存在对应 Annotation 对象*/ public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) &#123; return GenericDeclaration.super.isAnnotationPresent(annotationClass); &#125;/**获取 Annotation 对象*/ public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) &#123; Objects.requireNonNull(annotationClass); return (A) annotationData().annotations.get(annotationClass); &#125;/**获取所有 Annotation 对象数组*/ public Annotation[] getAnnotations() &#123; return AnnotationParser.toArray(annotationData().annotations); &#125; 下面结合前面的例子，我们来获取下注解的属性，在获取之前我们自定义的注解必须使用元注解@Retention(RetentionPolicy.RUNTIME)。 待续…","categories":[{"name":"开发","slug":"开发","permalink":"http://www.wblog.work/categories/开发/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.wblog.work/tags/Java/"}]}]}
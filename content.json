{"meta":{"title":"wenbing-blog","subtitle":"记录生活记录你","description":"如果你不是经常遇到挫折，这表明你做的事情没有很大的创新性","author":"gs-wenbing","url":"http://www.wblog.work","root":"/"},"pages":[{"title":"分类","date":"2019-09-20T05:17:46.000Z","updated":"2019-09-25T08:59:32.538Z","comments":false,"path":"categories/index.html","permalink":"http://www.wblog.work/categories/index.html","excerpt":"","text":""},{"title":"���","date":"2019-09-26T09:10:07.000Z","updated":"2019-09-26T09:15:51.337Z","comments":false,"path":"photos/index.html","permalink":"http://www.wblog.work/photos/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-09-20T01:21:27.000Z","updated":"2019-09-25T09:01:38.196Z","comments":false,"path":"tags/index.html","permalink":"http://www.wblog.work/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-09-26T09:21:27.000Z","updated":"2019-09-27T02:20:19.157Z","comments":false,"path":"about/index.html","permalink":"http://www.wblog.work/about/index.html","excerpt":"","text":"记录生活记录你"}],"posts":[{"title":"Rxjava2 - timer-interval-range-intervalRange示例和详细解析","slug":"Rxjava2-timer-interval-range-intervalRange示例和详细解析","date":"2019-10-08T05:22:27.000Z","updated":"2019-10-09T03:12:19.385Z","comments":true,"path":"Rxjava2-timer-interval-range-intervalRange示例和详细解析/","link":"","permalink":"http://www.wblog.work/Rxjava2-timer-interval-range-intervalRange示例和详细解析/","excerpt":"Rxjava2 - timer/interval/range/intervalRange示例和详细解析","text":"Rxjava2 - timer/interval/range/intervalRange示例和详细解析 timer示例11234567891011121314151617181920212223242526Observable.timer(5, TimeUnit.SECONDS) .subscribe(myObserver());private Observer&lt;? super Long&gt; myObserver() &#123; return new Observer&lt;Long&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; System.out.println(\"onSubscribe\"); &#125; @Override public void onNext(Long aLong) &#123; System.out.println(\"接收-----&gt;\" + aLong); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; System.out.println(\"onComplete\"); &#125; &#125;;&#125; 12308-26 15:37:06.813 12178-12178/com.zwb.rxjavademo I/System.out: onSubscribe08-26 15:37:11.817 12178-12208/com.zwb.rxjavademo I/System.out: 接收-----&gt;008-26 15:37:11.817 12178-12208/com.zwb.rxjavademo I/System.out: onComplete 分析返回一个Observable，它在延迟一段给定的时间（5s）后发射一个简单的数字0。 操作符默认在computation调度器上执行。有一个变体可以通过可选参数指定Scheduler。 比如指定在newThread线程：Observable.timer(5, TimeUnit.SECONDS, Schedulers.newThread()) intervalInterval操作符返回一个Observable，它按固定的时间间隔（2s）发射一个无限递增的整数序列。 interval默认在computation调度器上执行。你也可以传递一个可选的Scheduler参数来指定调度器。 示例123//延迟 5s，间隔 2s，发送无限增长的 Long 型数列Observable.interval(5,2,TimeUnit.SECONDS) .subscribe(myObserver()); 12345678908-26 16:29:45.407 13381-13381/com.zwb.rxjavademo I/System.out: onSubscribe//延时了5s执行，间隔是2s08-26 16:29:50.410 13381-13410/com.zwb.rxjavademo I/System.out: 接收-----&gt;008-26 16:29:52.411 13381-13410/com.zwb.rxjavademo I/System.out: 接收-----&gt;108-26 16:29:54.411 13381-13410/com.zwb.rxjavademo I/System.out: 接收-----&gt;208-26 16:29:56.410 13381-13410/com.zwb.rxjavademo I/System.out: 接收-----&gt;308-26 16:29:58.410 13381-13410/com.zwb.rxjavademo I/System.out: 接收-----&gt;408-26 16:30:00.411 13381-13410/com.zwb.rxjavademo I/System.out: 接收-----&gt;5...... 分析interval有四个重载方法： 12345678// 延时和间隔都是 periodpublic static Observable&lt;Long&gt; interval(long period, TimeUnit unit)// 延时initialDelay，间隔 periodpublic static Observable&lt;Long&gt; interval(long initialDelay, long period, TimeUnit unit)// 延时和间隔都是 period，指定Schedulerpublic static Observable&lt;Long&gt; interval(long period, TimeUnit unit, Scheduler scheduler)// 延时initialDelay，间隔 period，指定Schedulerpublic static Observable&lt;Long&gt; interval(long initialDelay, long period, TimeUnit unit, Scheduler scheduler) range 和 rangeLongRange操作符发射一个范围内的有序整数序列，你可以指定范围的起始和长度。 RxJava将这个操作符实现为range函数，它接受两个参数，一个是范围的起始值，一个是范围的数据的数目。如果你将第二个参数设为0，将导致Observable不发射任何数据（如果设置为负数，会抛异常）。 range默认不在任何特定的调度器上执行。有一个变体可以通过可选参数指定Scheduler。 示例123// 从 2 开始发送 5 个数据，区间为 [2,7)Observable.rangeLong(2,5) .subscribe(myObserver()); 123456708-26 17:14:04.780 14035-14035/com.zwb.rxjavademo I/System.out: onSubscribe08-26 17:14:04.780 14035-14035/com.zwb.rxjavademo I/System.out: 接收-----&gt;208-26 17:14:04.780 14035-14035/com.zwb.rxjavademo I/System.out: 接收-----&gt;308-26 17:14:04.780 14035-14035/com.zwb.rxjavademo I/System.out: 接收-----&gt;408-26 17:14:04.780 14035-14035/com.zwb.rxjavademo I/System.out: 接收-----&gt;508-26 17:14:04.780 14035-14035/com.zwb.rxjavademo I/System.out: 接收-----&gt;608-26 17:14:04.780 14035-14035/com.zwb.rxjavademo I/System.out: onComplete 分析intervalRangeintervalRange 可以指定发送事件的开始值和数量，用法和interval相同 示例123// 延迟 2s, 间隔 1s,从 2 开始发送 5 个数据Observable.intervalRange(2,5,2,1,TimeUnit.SECONDS) .subscribe(myObserver()); 1234567808-26 17:22:46.587 14314-14314/com.zwb.rxjavademo I/System.out: onSubscribe//延时了2s执行，间隔是1s08-26 17:22:48.589 14314-14348/com.zwb.rxjavademo I/System.out: 接收-----&gt;208-26 17:22:49.589 14314-14348/com.zwb.rxjavademo I/System.out: 接收-----&gt;308-26 17:22:50.589 14314-14348/com.zwb.rxjavademo I/System.out: 接收-----&gt;408-26 17:22:51.589 14314-14348/com.zwb.rxjavademo I/System.out: 接收-----&gt;508-26 17:22:52.588 14314-14348/com.zwb.rxjavademo I/System.out: 接收-----&gt;608-26 17:22:52.588 14314-14348/com.zwb.rxjavademo I/System.out: onComplete 分析","categories":[{"name":"技术","slug":"技术","permalink":"http://www.wblog.work/categories/技术/"},{"name":"RxJava2","slug":"技术/RxJava2","permalink":"http://www.wblog.work/categories/技术/RxJava2/"}],"tags":[{"name":"Rxjava","slug":"Rxjava","permalink":"http://www.wblog.work/tags/Rxjava/"}]},{"title":"Rxjava2 - buffer示例和源码解析","slug":"Rxjava2-buffer示例和源码解析","date":"2019-10-08T05:21:27.000Z","updated":"2019-10-09T03:12:26.591Z","comments":true,"path":"Rxjava2-buffer示例和源码解析/","link":"","permalink":"http://www.wblog.work/Rxjava2-buffer示例和源码解析/","excerpt":"buffer示例和源码解析","text":"buffer示例和源码解析 Buffer收集Observable的数据放进一个数据包裹，然后发射这些数据包裹，而不是一次发射一个值。 Buffer 操作符将一个 Observable 变换为另一个，原来的 Observable 正常发射数据，变换产生的 Observable 发射这些数据的缓存集合。 注意：如果原来的Observable发射了一个onError通知，Buffer会立即传递这个通知，而不是首先发射缓存的数据，即使在这之前缓存中包含了原始Observable发射的数据。 buffer(count, skip)示例1234567891011121314List&lt;Integer&gt; integers = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 20; i++) &#123; integers.add(i);&#125;Observable&lt;Integer&gt; observable = Observable.fromIterable(integers);observable .buffer(5，4) .subscribe(new Consumer&lt;List&lt;Integer&gt;&gt;() &#123; @Override public void accept(List&lt;Integer&gt; integers) throws Exception &#123; System.out.println(\"接收-----&gt;\" + integers); &#125; &#125;); 12345System.out: 接收-----&gt;[0, 1, 2, 3, 4]System.out: 接收-----&gt;[4, 5, 6, 7, 8]System.out: 接收-----&gt;[8, 9, 10, 11, 12]System.out: 接收-----&gt;[12, 13, 14, 15, 16]System.out: 接收-----&gt;[16, 17, 18, 19] 每个缓存里面包含 count 个元素，我们这里把数据列表 假设为List，索引为index。那么下一个缓存是以 index % skip == 0 开始，取 count 个元素。 我们从上面的打印日志中就可以看出，每个缓存的 开始元素索引和skip取余都为0。我们也可以通俗的理解为 先取 count 个元素，然后每隔 skip 个再取 count 个。 我们把skip为6看下输出结果： 12345678// 0 % 6==0ystem.out: 接收-----&gt;[0, 1, 2, 3, 4]// 6 % 6==0System.out: 接收-----&gt;[6, 7, 8, 9, 10]// 12 % 6==0System.out: 接收-----&gt;[12, 13, 14, 15, 16]// 18 % 6==0System.out: 接收-----&gt;[18, 19] 分析我们看下源码： 先从 buffer(count) 点进去，他调用的是 buffer(count, skip)， 只是参数skip 也是count， 而 buffer(count, skip) 调用的是 buffer(count, skip，bufferSupplier)，那么我们看下 buffer(count, skip，bufferSupplier)： 12345678910public final &lt;U extends Collection&lt;? super T&gt;&gt; Observable&lt;U&gt; buffer(int count, int skip, Callable&lt;U&gt; bufferSupplier) &#123; // count 必须大于0 ObjectHelper.verifyPositive(count, \"count\"); // skip 必须大于0 ObjectHelper.verifyPositive(skip, \"skip\"); //bufferSupplier 不能为null ObjectHelper.requireNonNull(bufferSupplier, \"bufferSupplier is null\"); //装配 ObservableBuffer 对象返回 return RxJavaPlugins.onAssembly(new ObservableBuffer&lt;T, U&gt;(this, count, skip, bufferSupplier));&#125; 我们知道，订阅的时候调用的 subscribe 方法，而 subscribe 调用是Observable的子类的 subscribeActual 方法，而这里Observable的子类就是 ObservableBuffer。 1234567891011protected void subscribeActual(Observer&lt;? super U&gt; t) &#123; //第一种情况： 当skip 和 count相等，或者 buffer(count)时会走这里 if (skip == count) &#123; BufferExactObserver&lt;T, U&gt; bes = new BufferExactObserver&lt;T, U&gt;(t, count, bufferSupplier); if (bes.createBuffer()) &#123; source.subscribe(bes); &#125; &#125; else &#123;//第二种情况： 当skip 和 count不相等时 source.subscribe(new BufferSkipObserver&lt;T, U&gt;(t, count, skip, bufferSupplier)); &#125;&#125; 我们分两种情况看： 首先第一种： 创建了一个 BufferExactObserver 对象，然后执行 bes.createBuffer() ： 12345678910111213141516171819202122boolean createBuffer() &#123; //这里的 U 的类型是 List&lt;Integer&gt; U b; try &#123; //创建一个空的 ArrayList，bufferSupplier是ArrayListSupplier的对象， //他的call执行了 return new ArrayList&lt;Object&gt;(); b = ObjectHelper.requireNonNull(bufferSupplier.call(), \"Empty buffer supplied\"); &#125; catch (Throwable t) &#123; Exceptions.throwIfFatal(t); buffer = null; if (upstream == null) &#123; EmptyDisposable.error(t, downstream); &#125; else &#123; upstream.dispose(); downstream.onError(t); &#125; return false; &#125; // 把空的ArrayList赋给 buffer，buffer是一个List&lt;Integer&gt;类型的变量 buffer = b; return true;&#125; 我们看到这里没有异常的话都返回true，所以一般都会执行 source.subscribe(bes)，这里的source其实是我们示例里Observable.fromIterable(integers) 返回的 ObservableFromIterable对象，fromIterable 我们已经分析过。 我们知道 fromIterable 是遍历 Iterable，而每遍历一项数据都会执行 BufferExactObserver 的 onNext，所以我们直接看下onNext的代码： 1234567891011121314151617181920/** * fromIterable 遍历 Iterable，执行onNext * @param t 每遍历一项数据 发射的Item */public void onNext(T t) &#123; //buffer 上面创建的空的 ArrayList U b = buffer; if (b != null) &#123; // t 是fromIterable中返回的每一条item数据 b.add(t); // size 记录存入缓存区的元素个数，当元素个数&gt;=我们传进去的大小时，就发射一个count大小的缓冲区 //发射完后，元素个数赋值为0，重新创建一个新的缓存区覆盖原来的缓存区 if (++size &gt;= count) &#123; //发射一个count大小的缓冲区 downstream.onNext(b); size = 0; createBuffer(); &#125; &#125;&#125; 我们看到onNext 发射的都是count大小的缓冲，但是假如我们传的数据不是count倍数时，比如24条数据，缓存大小为5，其中20条分四个缓存发射了，那剩下的4就不会发射了吗？ 我们从onNext中看到，不管有没有count个元素，都会放到缓存 b 中，而剩下4条会在onComplete()中发射 12345678910111213141516/** * 1、缓存中还有元素，发射剩下的元素，执行onComplete * 2、缓存中没有元素，直接执行onComplete */public void onComplete() &#123; U b = buffer; if (b != null) &#123; buffer = null; // 这时的缓存区的元素就是剩下的4条元素（假如数据总数不是count的倍数） if (!b.isEmpty()) &#123; downstream.onNext(b); &#125; //发送完成后执行 onComplete downstream.onComplete(); &#125;&#125; 上面就是buffer(count)的整个流程。 第二种情况 （buffer(count, skip)）： 从 subscribeActual 方法中我们看到第二种情况直接执行了下面代码： source.subscribe(new BufferSkipObserver&lt;T, U&gt;(t, count, skip, bufferSupplier)); 同样 subscribe 也是走了 fromIterable 的流程，和上面的一样。 我们直接看 BufferSkipObserver 的 onNext方法： 1234567891011121314151617181920212223242526272829303132333435363738/** * fromIterable 遍历 Iterable，执行onNext * @param t 每遍历一项数据 发射的Item */public void onNext(T t) &#123; // index是遍历 Iterable的索引，判断index+1后和skip取余是否等于0 //假如取余等于0，重新创建一个缓存 if (index++ % skip == 0) &#123; //U 是 List&lt;Integer&gt;类型的 U b; try &#123; //创建一个空的 ArrayList b = ObjectHelper.requireNonNull(bufferSupplier.call(), \"The bufferSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.\"); &#125; catch (Throwable e) &#123; buffers.clear(); upstream.dispose(); downstream.onError(e); return; &#125; //buffers 是ArrayDeque类型的对象，把空的ArrayList存入到 buffers中，当做一个缓存区 //当count &gt; slip时，buffers中可能同时会有多个缓存区，这个时候缓存会有重叠的元素 //当count &lt; slip时，buffers在某些情况下没有缓存区，这个时候会有间隙，也就是说部分数据会丢失 buffers.offer(b); &#125; Iterator&lt;U&gt; it = buffers.iterator(); //遍历buffers while (it.hasNext()) &#123; //获取 buffers 中每一个缓存ArrayList，把当前发射的Item存到缓存区 U b = it.next(); b.add(t); //判断当前缓存区是否已满 if (count &lt;= b.size()) &#123; //如果已满，则发射当前缓存区数据，删除当前缓存区 it.remove(); downstream.onNext(b); &#125; &#125;&#125; 同样的当最后数据不足一个缓存的大小时，会执行onComplete方法： 12345678910@Overridepublic void onComplete() &#123; //判断buffers是否存在缓存 while (!buffers.isEmpty()) &#123; //假如有 直接发射缓存区中的所有元素 downstream.onNext(buffers.poll()); &#125; //执行onComplete 回调 downstream.onComplete();&#125; buffer(timespan, unit)示例示例1 12345678910111213141516171819202122232425Observable //表示发射10条整数序列，每间隔 100ms发射一条 .interval(100, TimeUnit.MILLISECONDS).take(10) .buffer(300, TimeUnit.MILLISECONDS) .subscribe(new Observer&lt;List&lt;Long&gt;&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; System.out.println(\"onSubscribe\"); &#125; @Override public void onNext(List&lt;Long&gt; longs) &#123; System.out.println(longs); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; System.out.println(\"onComplete\"); &#125; &#125;); 123456708-29 14:34:32.359 8656-8656/com.zwb.rxjavademo I/System.out: onSubscribe08-29 14:34:32.661 8656-8729/com.zwb.rxjavademo I/System.out: [0, 1, 2]08-29 14:34:32.960 8656-8729/com.zwb.rxjavademo I/System.out: [3, 4]08-29 14:34:33.261 8656-8729/com.zwb.rxjavademo I/System.out: [5, 6, 7]//中间隔了200ms08-29 14:34:33.361 8656-8730/com.zwb.rxjavademo I/System.out: [8, 9]08-29 14:34:33.361 8656-8730/com.zwb.rxjavademo I/System.out: onComplete 打印日志的第四行和第五行才隔了200ms，而不是我们设置的300ms，这个我们下面会分析 分析我们看下源码：从 buffer 点击去，最后执行的是 1234567891011public final &lt;U extends Collection&lt;? super T&gt;&gt; Observable&lt;U&gt; buffer( long timespan, TimeUnit unit, Scheduler scheduler, int count, Callable&lt;U&gt; bufferSupplier, boolean restartTimerOnMaxSize) &#123; //判断数据的合法性 //。。。。。。 //装配 ObservableBufferTimed 对象返回 return RxJavaPlugins.onAssembly(new ObservableBufferTimed&lt;T, U&gt;(this, timespan, timespan, unit, scheduler, bufferSupplier, count, restartTimerOnMaxSize));&#125; 我们知道真正订阅是在ObservableBufferTimed类的subscribeActual方法中，我们看下： 1234567891011121314151617181920212223242526protected void subscribeActual(Observer&lt;? super U&gt; t) &#123; //第一种情况，buffer(timespan, unit) 会走这里，也就是示例1 if (timespan == timeskip &amp;&amp; maxSize == Integer.MAX_VALUE) &#123; //我们暂且把这行称为 【代码1】 source.subscribe(new BufferExactUnboundedObserver&lt;T, U&gt;( new SerializedObserver&lt;U&gt;(t), bufferSupplier, timespan, unit, scheduler)); return; &#125; //第二种情况 Scheduler.Worker w = scheduler.createWorker(); if (timespan == timeskip) &#123; source.subscribe(new BufferExactBoundedObserver&lt;T, U&gt;( new SerializedObserver&lt;U&gt;(t), bufferSupplier, timespan, unit, maxSize, restartTimerOnMaxSize, w )); return; &#125; //第三种情况 source.subscribe(new BufferSkipBoundedObserver&lt;T, U&gt;( new SerializedObserver&lt;U&gt;(t), bufferSupplier, timespan, timeskip, unit, w));&#125; 我们这里只分析第一种情况： 【代码1】就一行代码，但是这行代码其实很复杂的。 source(被观察者) 是执行 interval 时创建的 ObservableInterval 对象 ，而执行 subscribe 时会执行 ObservableInterval 的 subscribeActual，而 ObservableInterval 的 subscribeActual 默认会在computation线程每隔 100ms（示例1中设置的） 发送一条整数序列，也就是执行一次 onNext （注意：这里的onNext不会走 我们的示例的中onNext）。 下面是 ObservableInterval 的部分代码： 1234567891011121314151617181920212223public void subscribeActual(Observer&lt;? super Long&gt; observer) &#123; IntervalObserver is = new IntervalObserver(observer); //这行先标记下 标记1 observer.onSubscribe(is); Scheduler sch = scheduler; if (sch instanceof TrampolineScheduler) &#123; Worker worker = sch.createWorker(); is.setResource(worker); worker.schedulePeriodically(is, initialDelay, period, unit); &#125; else &#123; Disposable d = sch.schedulePeriodicallyDirect(is, initialDelay, period, unit); is.setResource(d); &#125;&#125;@Overridepublic void run() &#123; if (get() != DisposableHelper.DISPOSED) &#123; //标记2 downstream.onNext(count++); &#125;&#125; interval参考 interval 示例和详细解析 我们从这里没看到什么时候执行onComplete的方法，也就说明了Interval是无限发射数据的，但是我们上面的日志打印了onComplete方法，其实是take中 执行了onComplete方法。 我们回过头再看【代码1】里面创建了两个类：BufferExactUnboundedObserver 和 SerializedObserver，这两个类把我们自己创建的观察者 Observer 又包装了两次。 123source.subscribe(new BufferExactUnboundedObserver&lt;T, U&gt;( new SerializedObserver&lt;U&gt;(t), bufferSupplier, timespan, unit, scheduler)); 但是在传到 ObservableInterval 的 subscribeActual方法中的是 BufferExactUnboundedObserver的对象，所以上面的 标记1（onSubscribe）和 标记2（onNext）会执行 BufferExactUnboundedObserver 的 onSubscribe和onNext方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Overridepublic void onSubscribe(Disposable d) &#123; if (DisposableHelper.validate(this.upstream, d)) &#123; this.upstream = d; //同样的U 是 List&lt;Integer&gt;类型的 U b; try &#123; //创建一个空的 ArrayList b = ObjectHelper.requireNonNull(bufferSupplier.call(), \"The buffer supplied is null\"); &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); dispose(); EmptyDisposable.error(e, downstream); return; &#125; // 把空的ArrayList赋给 buffer，buffer是一个List&lt;Integer&gt;类型的变量 buffer = b; // downstream 是SerializedObserver的对象，执行他的onSubscribe // 标记3 downstream.onSubscribe(this); if (!cancelled) &#123; // 这个地方很重要，里面也比较复杂，涉及到 scheduler 的知识点 // 简单点理解，就是执行一个定时任务，最后回调是 run 方法中 Disposable task = scheduler.schedulePeriodicallyDirect(this, timespan, timespan, unit); if (!timer.compareAndSet(null, task)) &#123; task.dispose(); &#125; &#125; &#125;&#125;/** * 这里是把interval 每发射的数据存到 buffer里面 * @param t t在这里是 interval 每隔100ms 发射的整数 */@Overridepublic void onNext(T t) &#123; synchronized (this) &#123; U b = buffer; if (b == null) &#123; return; &#125; b.add(t); &#125;&#125; scheduler参考 scheduler的详细解析 我们看到在 onSubscribe 中执行一个定时任务，最后回调是 run 方法中: 12345678910111213141516171819202122232425262728293031323334353637383940@Overridepublic void run() &#123; // 存放下一个时间段的数据 U next; try &#123; next = ObjectHelper.requireNonNull(bufferSupplier.call(), \"The bufferSupplier returned a null buffer\"); &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); downstream.onError(e); dispose(); return; &#125; // 存放当前数据，， U current; synchronized (this) &#123; //把buffer中的数据存进去 current = buffer; if (current != null) &#123; //然后buffer存放下个时间段的数据 buffer = next; &#125; &#125; if (current == null) &#123; DisposableHelper.dispose(timer); return; &#125; // 执行父类的 fastPathEmit，里面执行了accept，也就是下面的方法 fastPathEmit(current, false, this);&#125;/** * @param a * @param v 就是上面的 current，也就是要发射的一个缓存区 */@Overridepublic void accept(Observer&lt;? super U&gt; a, U v) &#123; //downstream 是SerializedObserver的对象，执行他的onNext //标记4 downstream.onNext(v);&#125; 我们从上面代码中看到，标注3 *和 *标注4 的 onSubscribe 和 onNext 方法是 SerializedObserver中的， 1234567891011121314151617181920@Overridepublic void onSubscribe(@NonNull Disposable d) &#123; if (DisposableHelper.validate(this.upstream, d)) &#123; this.upstream = d; // 这里才执行了 我们自己创建的 Observer 的 onSubscribe 回调 downstream.onSubscribe(this); &#125;&#125;/** * * @param t 这里的 t 是上面创建的一组数据缓存 */@Overridepublic void onNext(@NonNull T t) &#123; //....... //我们只看这行代码，发射数据缓存 downstream.onNext(t);&#125; 我们看到最后给我们自己创建的观察者发射数据是在 SerializedObserver 中，包括onSubscribe、onComplete的回调 但是整个流程还没完，我们打印的日志里 第四条和第五条的时间间隔不是我们设置的300ms，这是怎么回事呢 我们知道其实上面的代码中我们看到了两个线程在执行，一个是interval的线程隔100ms发射数据给buffer，另个一是buffer的线程每个300ms发射数据缓存 ，但是这俩个线程是异步的，也就是说interval(100, TimeUnit.MILLISECONDS).take(10)发射的10条数据完成后会直接执行onComplete()，而onComplete()把剩下的数据缓存全部发射，并且onComplete()也不需要等待300ms后在执行。 这里take的onComplete()最终会调用 BufferExactUnboundedObserver 的 onComplete方法： 12345678910111213141516171819202122@Overridepublic void onComplete() &#123; U b; synchronized (this) &#123; b = buffer; //清空 buffer buffer = null; &#125; if (b != null) &#123; queue.offer(b); // done设置为true后执行downstream（SerializedObserver） 的onComplete方法， // 因为SerializedObserver的onComplete方法才是正在执行我们创建的观察者的onComplete的方法 done = true; if (enter()) &#123; //1、执行BufferExactUnboundedObserver 的 accept //2、执行SerializedObserver的onComplete QueueDrainHelper.drainLoop(queue, downstream, false, null, this); &#125; &#125; // 结束buffer的定时任务 DisposableHelper.dispose(timer);&#125; 这样buffer(timespan, unit) 的整个流程就分析完了。上面示例分析加了interval 和 take ，所以会有些复杂。下面看下简单的示例 123456789101112131415161718192021222324252627282930313233Observable .create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; for (int i=0;i&lt;10;i++)&#123; emitter.onNext(i); Thread.sleep(100); &#125; emitter.onComplete(); &#125; &#125;) .buffer(300, TimeUnit.MILLISECONDS) .subscribe(new Observer&lt;List&lt;Integer&gt;&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; System.out.println(\"onSubscribe\"); &#125; @Override public void onNext(List&lt;Integer&gt; longs) &#123; System.out.println(longs); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; System.out.println(\"onComplete\"); &#125; &#125;); 123456I/System.out: onSubscribeI/System.out: [0, 1, 2]I/System.out: [3, 4, 5]I/System.out: [6, 7, 8]I/System.out: [9]I/System.out: onComplete 时序图如下：","categories":[{"name":"技术","slug":"技术","permalink":"http://www.wblog.work/categories/技术/"},{"name":"RxJava2","slug":"技术/RxJava2","permalink":"http://www.wblog.work/categories/技术/RxJava2/"}],"tags":[{"name":"Rxjava","slug":"Rxjava","permalink":"http://www.wblog.work/tags/Rxjava/"}]},{"title":"Rxjava2 - defer示例和详细解析","slug":"Rxjava2-defer示例和详细解析","date":"2019-10-08T05:21:27.000Z","updated":"2019-10-09T03:11:41.875Z","comments":true,"path":"Rxjava2-defer示例和详细解析/","link":"","permalink":"http://www.wblog.work/Rxjava2-defer示例和详细解析/","excerpt":"defer示例和详细解析","text":"defer示例和详细解析 defer示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 创建被观察者 * @return ObservableSource */private ObservableSource&lt;? extends Integer&gt; getSource() &#123; return Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; System.out.println(\"发射-----&gt;\" + Thread.currentThread().getName() + \"--:\" + 1); emitter.onNext(1); emitter.onComplete(); &#125; &#125;);&#125;/** * 创建观察者 * @return Observer */private Observer&lt;? super Integer&gt; getObserver() &#123; return new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; System.out.println(\"onSubscribe\"); &#125; @Override public void onNext(Integer integer) &#123; System.out.println(\"接收-----&gt;\" + integer); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; System.out.println(\"onComplete\"); &#125; &#125;;&#125;public void testDefer() &#123; Observable&lt;Integer&gt; source = Observable .defer(new Callable&lt;ObservableSource&lt;? extends Integer&gt;&gt;() &#123; @Override public ObservableSource&lt;? extends Integer&gt; call() throws Exception &#123; return getSource(); &#125; &#125;); source .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(getObserver()); source .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(getObserver());&#125; 12345678System.out: onSubscribe //先订阅System.out: onSubscribeSystem.out: 发射-----&gt;RxCachedThreadScheduler-1--:1 //再发射数据System.out: 发射-----&gt;RxCachedThreadScheduler-2--:1System.out: 接收-----&gt;1System.out: onCompleteSystem.out: 接收-----&gt;1System.out: onComplete 分析根据日志可以看出，直到有观察者订阅时才创建 Observable ，并且为每个观察者创建一个新的 Observable 。 Defer操作符会一直等待直到有观察者订阅它，然后它使用Observable工厂方法生成一个Observable。它对每个观察者都这样做，因此尽管每个订阅者都以为自己订阅的是同一个Observable，事实上每个订阅者获取的是它们自己的单独的数据序列。 我们点进去看下 defer ， 其实也返回了一个 Observable 子类的对象 ObservableDefer 那么接下来我们之间看 subscribeActual 方法的实现： 12345678910111213public void subscribeActual(Observer&lt;? super T&gt; observer) &#123; ObservableSource&lt;? extends T&gt; pub; try &#123; //返回我们通过 getSourse() 创建的 被观察者， pub = ObjectHelper.requireNonNull(supplier.call(), \"null ObservableSource supplied\"); &#125; catch (Throwable t) &#123; Exceptions.throwIfFatal(t); EmptyDisposable.error(t, observer); return; &#125; pub.subscribe(observer);&#125; 我们每次执行 source.subscribe(getObserver()) ;就会调用一次 subscribeActual方法，也就会通过 upplier.call() 返回我们新创建的被观察者，也就验证了 “直到有观察者订阅时才创建 Observable ，并且为每个观察者创建一个新的 Observable”。 我们再看下 pub.subscribe(observer); 这一行代码，pub 就是我们 getSourse() 时通过 create 创建的 Observable，这里的 pub.subscribe() 其实是执行了 ObservableCreate 的 subscribeActual 方法，接下来的流程就和 create 的订阅过程 一样了。","categories":[{"name":"技术","slug":"技术","permalink":"http://www.wblog.work/categories/技术/"},{"name":"RxJava2","slug":"技术/RxJava2","permalink":"http://www.wblog.work/categories/技术/RxJava2/"}],"tags":[{"name":"Rxjava","slug":"Rxjava","permalink":"http://www.wblog.work/tags/Rxjava/"}]},{"title":"Rxjava2 - from示例和源码解析","slug":"Rxjava2-from示例和源码解析","date":"2019-10-08T05:21:27.000Z","updated":"2019-10-09T03:11:50.304Z","comments":true,"path":"Rxjava2-from示例和源码解析/","link":"","permalink":"http://www.wblog.work/Rxjava2-from示例和源码解析/","excerpt":"from示例和源码解析","text":"from示例和源码解析 fromIterable()：遍历 Iterable，和 just() 方式一样直接触发 onNext()，然后返回每项数据 示例12345678910111213List&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.add(0);list.add(1);list.add(2);list.add(3);mDisposables.add(Observable .fromIterable(list) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; System.out.println(\"接收-----&gt;\"+integer); &#125; &#125;)); 输出日志： 1234接收-----&gt;0接收-----&gt;1接收-----&gt;2接收-----&gt;3 分析我们通过源码可以看到 fromIterable 通过 Iterable 构造了一个 ObservableFromIterable 然后返回。 12345public static &lt;T&gt; Observable&lt;T&gt; fromIterable(Iterable&lt;? extends T&gt; source) &#123; ObjectHelper.requireNonNull(source, \"source is null\"); // 通过 Iterable 构造了一个 ObservableFromIterable 返回 return RxJavaPlugins.onAssembly(new ObservableFromIterable&lt;T&gt;(source));&#125; ObservableFromIterable 继承 Observable。 接下来我们回到订阅过程，其订阅过程前面的内容跟上一节分析的是一样的，就不重复了。还记得订阅过程中 Observable 类的 subscribeActual() 是个抽象方法吗？他的真正实现是在 ObservableFromIterable 中，所以我们来看下 subscribeActual 方法： 123456789101112131415161718192021public final class ObservableFromIterable&lt;T&gt; extends Observable&lt;T&gt; &#123; final Iterable&lt;? extends T&gt; source; public ObservableFromIterable(Iterable&lt;? extends T&gt; source) &#123; this.source = source; &#125; @Override public void subscribeActual(Observer&lt;? super T&gt; observer) &#123; ...... // 把我们创建的 Observer 和 传的 Iterable 包装成 FromIterableDisposable FromIterableDisposable&lt;T&gt; d = new FromIterableDisposable&lt;T&gt;(observer, it); observer.onSubscribe(d); if (!d.fusionMode) &#123; d.run(); &#125; &#125; ...... //内部静态类 FromIterableDisposable&#125; 同样也将我们自定义的 Observer 给包装成了一个新的 FromIterableDisposable 对象，然后调用 observer.onSubscribe(d) 设置了观察者的onSubscribe方法的回调。所以观察者onSubscribe()是在订阅时被调用，也就是在事件执行之前调用。最后执行 d.run()。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758static final class FromIterableDisposable&lt;T&gt; extends BasicQueueDisposable&lt;T&gt; &#123; //我们创建的 观察者 Observer final Observer&lt;? super T&gt; downstream; //我们传的参数 Iterator final Iterator&lt;? extends T&gt; it; volatile boolean disposed; boolean fusionMode; boolean done; boolean checkNext; FromIterableDisposable(Observer&lt;? super T&gt; actual, Iterator&lt;? extends T&gt; it) &#123; this.downstream = actual; this.it = it; &#125; void run() &#123; boolean hasNext; //循环 Iterator do &#123; // 消息断开后直接返回 if (isDisposed()) &#123; return; &#125; T v; try &#123; v = ObjectHelper.requireNonNull(it.next(), \"The iterator returned a null value\"); &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); downstream.onError(e); return; &#125; // 执行 观察者 Observer 的回调 onNext() downstream.onNext(v); // 消息断开后直接返回 if (isDisposed()) &#123; return; &#125; try &#123; hasNext = it.hasNext(); &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); downstream.onError(e); return; &#125; &#125; while (hasNext); // 循环结束执行onComplete() (循环结束isDisposed()都是false，否则在循环中就已经返回了) if (!isDisposed()) &#123; downstream.onComplete(); &#125; &#125; ......&#125; fromArray()：遍历 数组，和 just() 方式一样直接触发 onNext()，然后返回每项数据fromArray和多参数just一样，只不过 fromArray 可以传入多于10个的变量，并可传入一个数组 示例示例1 123456789mDisposables.add(Observable //把 int 装箱成 Integer，所以返回的每个item .fromArray(0,1,2,3) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; System.out.println(\"接收-----&gt;\"+integer); &#125; &#125;)); 1234接收-----&gt;0接收-----&gt;1接收-----&gt;2接收-----&gt;3 示例2 12345678910Integer[] array = &#123;1, 2, 3, 4&#125;;mDisposables.add(Observable // 可传入一个数组 .fromArray(array) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; System.out.println(\"接收-----&gt;\"+integer); &#125; &#125;)); 1234接收-----&gt;0接收-----&gt;1接收-----&gt;2接收-----&gt;3 示例3 123456789101112//参数 int 类型 把整个array作为可变数据组的一个item，所以返回的是数组类型int[] array = &#123;1, 2, 3, 4&#125;;mDisposables.add(Observable // 可传入一个数组 .fromArray(array) .subscribe(new Consumer&lt;int[]&gt;() &#123; @Override public void accept(int[] ints) throws Exception &#123; //接收到的是数组的地址 System.out.println(\"接收-----&gt;\"+ints.length); &#125; &#125;)); 1接收-----&gt;[I@6d6f6e28 分析示例3和示例1、2的输入结果不一样，这个就涉及到java的 泛型T 以及 基本数据类型和其对应的包装类 相关的知识点，可自行查阅其他资料。 我的理解是 fromArray(T… items) 泛型T 理解成Object，当传int类型数组时，会把整个array当做一个item对象，但是当传入int 类型的多个变量时会自动装箱成Integer。其他八种基本数据类型一样的。 接下来我们看下fromArray的源码： 12345678910public static &lt;T&gt; Observable&lt;T&gt; fromArray(T... items) &#123; ObjectHelper.requireNonNull(items, \"items is null\"); if (items.length == 0) &#123; return empty(); &#125; else if (items.length == 1) &#123; return just(items[0]); &#125; return RxJavaPlugins.onAssembly(new ObservableFromArray&lt;T&gt;(items));&#125; 我们可以看到当只有一个参数时，就调用 just(T item)，多个参数时调用的和多个参数的just()是一样的，具体的可以查看just示例和源码解析 fromCallable()示例12345678910111213mDisposables.add(Observable .fromCallable(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; return 100; &#125; &#125;) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer i) throws Exception &#123; System.out.println(\"接收-----&gt;\"+i); &#125; &#125;)); 1接收-----&gt;100 分析我们先看下Callable是什么，原来是java.util.concurrent 包下的一个接口，里面只有一个带返回值的方法。再看 fromCallable 1234public static &lt;T&gt; Observable&lt;T&gt; fromCallable(Callable&lt;? extends T&gt; supplier) &#123; ObjectHelper.requireNonNull(supplier, \"supplier is null\"); return RxJavaPlugins.onAssembly(new ObservableFromCallable&lt;T&gt;(supplier));&#125; 同样的装配了一个 ObservableFromCallable 返回，作为我们的被观察者。我们知道正真订阅是实现 subscribeActual 方法的 Observable 的子类里面，所以我们直接 ObservableFromCallable 类： 123456789101112131415161718192021222324252627282930313233343536373839public final class ObservableFromCallable&lt;T&gt; extends Observable&lt;T&gt; implements Callable&lt;T&gt; &#123; //我们传进去的 Callable final Callable&lt;? extends T&gt; callable; public ObservableFromCallable(Callable&lt;? extends T&gt; callable) &#123; this.callable = callable; &#125; @Override public void subscribeActual(Observer&lt;? super T&gt; observer) &#123; //通过我们创建的 observer 创建了一个DeferredScalarDisposable对象 DeferredScalarDisposable&lt;T&gt; d = new DeferredScalarDisposable&lt;T&gt;(observer); //执行订阅回调 observer.onSubscribe(d); //中断后直接返回 if (d.isDisposed()) &#123; return; &#125; T value; try &#123; //callable.call()就是我们new的 Callable 中 call 方法的返回值 //这里做了非空判断，若如为空，直接抛出异常 value = ObjectHelper.requireNonNull(callable.call(), \"Callable returned null\"); &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); if (!d.isDisposed()) &#123; observer.onError(e); &#125; else &#123; RxJavaPlugins.onError(e); &#125; return; &#125; d.complete(value); &#125; @Override public T call() throws Exception &#123; return ObjectHelper.requireNonNull(callable.call(), \"The callable returned a null value\"); &#125;&#125; 通过上面代码，我们看到，创建了一个 DeferredScalarDisposable 对象，最后执行了d.complete(value)。接下来我们看 DeferredScalarDisposable 类的 complete 方法： 1234567891011121314151617181920public final void complete(T value) &#123; int state = get(); if ((state &amp; (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) &#123; return; &#125; Observer&lt;? super T&gt; a = downstream; if (state == FUSED_EMPTY) &#123; this.value = value; lazySet(FUSED_READY); a.onNext(null); &#125; else &#123; lazySet(TERMINATED); // 执行回调 onNext(),并把new的 Callable 中 call 方法的返回值作为参数 a.onNext(value); &#125; //假如没有执行dispose()，并执行完 onNext 方法后，接着执行onComplete if (get() != DISPOSED) &#123; a.onComplete(); &#125;&#125; 根据以上的分析，根据上面的分析,我们得出如下规则： 1、fromCallable 里的返回值就是 onNext 接收的参数。 2、通过 fromCallable() 方式 直接触发 onNext()，并执行 onComplete()。 fromFuture()示例1234567891011121314151617181920212223242526272829303132FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; Thread.sleep(5000); return \"返回值\"; &#125;&#125;);Observable .fromFuture(futureTask) .subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; System.out.println(\"onSubscribe\"); futureTask.run(); &#125; @Override public void onNext(String s) &#123; System.out.println(\"接收-----&gt;\" + s); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; System.out.println(\"onComplete\"); &#125; &#125;); 123System.out: onSubscribeSystem.out: 接收-----&gt;返回值System.out: onComplete 分析我们先简单的看下Future 和 FutureTast 。Future类位于java.util.concurrent包下，它也是一个接口。 Future就是对于具体的 Runnable 或者 Callable 任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。 FutureTask实现了RunableFuture接口，同时RunableFuture又继承Future，Runable接口，也就是说FutureTask具备Runbale的run方法执行异步任务，也可以像Future一样能够控制任务的执行。事实上，FutureTask是Future接口的一个唯一实现类。 详细用法查看Java并发编程：Callable、Future和FutureTask 接下来我们看下 fromFuture 的源码： 同样的装配了一个 ObservableFromFuture 返回，作为我们的被观察者。我们知道正真订阅是实现 subscribeActual 方法的 Observable 的子类里面，所以我们直接 ObservableFromFuture 类的： 1234567891011121314151617public void subscribeActual(Observer&lt;? super T&gt; observer) &#123; DeferredScalarDisposable&lt;T&gt; d = new DeferredScalarDisposable&lt;T&gt;(observer); observer.onSubscribe(d); if (!d.isDisposed()) &#123; T v; try &#123; v = ObjectHelper.requireNonNull(unit != null ? future.get(timeout, unit) : future.get(), \"Future returned null\"); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); if (!d.isDisposed()) &#123; observer.onError(ex); &#125; return; &#125; d.complete(v); &#125;&#125; 这个方法也很好理解，DeferredScalarDisposable 类和我们上面说的 fromCallable 的一样的，这里注意这一行代码：v = ObjectHelper.requireNonNull(unit != null ? future.get(timeout, unit) : future.get(), &quot;Future returned null&quot;); 假如我们不执行 futureTask.run(); 就会一直阻塞。","categories":[{"name":"技术","slug":"技术","permalink":"http://www.wblog.work/categories/技术/"},{"name":"RxJava2","slug":"技术/RxJava2","permalink":"http://www.wblog.work/categories/技术/RxJava2/"}],"tags":[{"name":"Rxjava","slug":"Rxjava","permalink":"http://www.wblog.work/tags/Rxjava/"}]},{"title":"Rxjava2 - just示例和源码解析","slug":"Rxjava2-just示例和源码解析","date":"2019-10-08T05:11:27.000Z","updated":"2019-10-09T03:11:54.943Z","comments":true,"path":"Rxjava2-just示例和源码解析/","link":"","permalink":"http://www.wblog.work/Rxjava2-just示例和源码解析/","excerpt":"just示例和源码解析","text":"just示例和源码解析 just()示例 12345678910111213141516171819Observable.just(\"文章1\", \"文章2\") .subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, \" onSubscribe : \" + d.isDisposed()); &#125; @Override public void onNext(String value) &#123; Log.d(TAG, \" onNext : \" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \" onError : \" + e.getMessage()); &#125; @Override public void onComplete() &#123; Log.d(TAG, \" onComplete\"); &#125; &#125;) Observable 的just()有10个重载方法，参数1~10个 123public static &lt;T&gt; Observable&lt;T&gt; just(T item)......public static &lt;T&gt; Observable&lt;T&gt; just(T item1, T item2, T item3, T item4, T item5, T item6, T item7, T item8, T item9, T item10) 同样的我们从以下几个方面分析源码： 被观察者Observable是何时创建 观察者Observer何时创建（很简单就一个接口，不多介绍） 被观察者与观察者如何建立subscribe订阅关系的 一个参数的 just()1. 被观察者Observable是何时创建12345 public static &lt;T&gt; Observable&lt;T&gt; just(T item) &#123; ObjectHelper.requireNonNull(item, \"The item is null\"); //创建ObservableJust对象，封装成被观察者Observable return RxJavaPlugins.onAssembly(new ObservableJust&lt;T&gt;(item));&#125; 创建了 ObservableJust 对象，调用 RxJavaPlugins.onAssembly 返回了被观察者 Observable. 1234567public static &lt;T&gt; Observable&lt;T&gt; onAssembly(@NonNull Observable&lt;T&gt; source) &#123; Function&lt;? super Observable, ? extends Observable&gt; f = onObservableAssembly; if (f != null) &#123; return apply(f, source); &#125; return source;&#125; 我们看下 ObservableJust 类，同样的也是继承 Observable。 12345678910111213141516171819public final class ObservableJust&lt;T&gt; extends Observable&lt;T&gt; implements ScalarCallable&lt;T&gt; &#123; private final T value; public ObservableJust(final T value) &#123; this.value = value; &#125; //这个方法很重要， 等会会说到 @Override protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; ScalarDisposable&lt;T&gt; sd = new ScalarDisposable&lt;T&gt;(observer, value); observer.onSubscribe(sd); sd.run(); &#125; @Override public T call() &#123; return value; &#125;&#125; 这时候被观察者已经创建完成了，它就是 Observable 的子类 ObservableJust，我们在用 Observable.just() 的时候其实被观察者是 ObservableJust。 2. Observable 和 Observer 如何建立 subscribe 订阅关系的123456789101112131415public final void subscribe(Observer&lt;? super T&gt; observer) &#123; try &#123; observer = RxJavaPlugins.onSubscribe(this, observer); subscribeActual(observer); &#125; catch (NullPointerException e) &#123; // NOPMD throw e; &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); RxJavaPlugins.onError(e); npe.initCause(e); throw npe; &#125;&#125; 这里的 Subscribe() 方法和 Observable.Create() 调的 Subscribe() 一样，我们知道 Subscribeactual() 这个方法是抽象方法，那它具体实现是不是和 Observable.Create() 一样也是 Observablecreate 类里呢？不是，不是，不是，重要的话说三遍哦，它的具体实现在我们看到 Observablejust 中。 那么我们回到 ObservableJust 中看下subscribeActual(Observer&lt;? super T&gt; observer) 12345678protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; //创建了一个线程 ScalarDisposable&lt;T&gt; sd = new ScalarDisposable&lt;T&gt;(observer, value); //设置observer的回调方法onSubscribe observer.onSubscribe(sd); //执行线程 sd.run();&#125; 这里面创建了一个线程（Runnable），他就是 ScalarDisposable ，ScalarDisposable实现Runnable，把我们创建的观察者Observer 和参数value （Observable.just(“文章1”) 这里的‘文章1’） 作为构造方法的参数传进去了， 同时他也是Disposable的子类，所以 observer.onSubscribe(sd); 这行就很好理解了，就是设置了观察者的onSubscribe方法的回调，所以观察者onSubscribe()是在订阅时被调用，也就是在事件执行之前调用。 1234567Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, \"onSubscribe\"); &#125; ...... 接下来看下 ScalarDisposable 类 123456789101112131415161718192021222324252627282930public static final class ScalarDisposable&lt;T&gt; extends AtomicInteger implements QueueDisposable&lt;T&gt;, Runnable &#123; private static final long serialVersionUID = 3880992722410194083L; //我们创建的观察者 final Observer&lt;? super T&gt; observer; //我们在just中传递的参数（文章1） final T value; static final int START = 0; static final int FUSED = 1; static final int ON_NEXT = 2; static final int ON_COMPLETE = 3; public ScalarDisposable(Observer&lt;? super T&gt; observer, T value) &#123; this.observer = observer; this.value = value; &#125; @Override public void run() &#123; if (get() == START &amp;&amp; compareAndSet(START, ON_NEXT)) &#123; observer.onNext(value); if (get() == ON_NEXT) &#123; lazySet(ON_COMPLETE); observer.onComplete(); &#125; &#125; &#125;&#125; 我们在subscribeActual()方法中看到最后执行了 sd.run(); 所以我们只需看 public void run() 这个方法，run()方法首先执行了 observer.onNext(value)， 也就是说我们在创建Observable时传的参数此时发送给observer，然后在执行observer.onComplete()。 这样，Observable.just() 一个参数的方法就结束了 多个参数的 just()同样的我们从以下几个方面分析源码： 1. 被观察者Observable是何时创建我们下看源码： 123456public static &lt;T&gt; Observable&lt;T&gt; just(T item1, T item2) &#123; ObjectHelper.requireNonNull(item1, \"The first item is null\"); ObjectHelper.requireNonNull(item2, \"The second item is null\"); return fromArray(item1, item2);&#125; 很简单，在往下看 fromArray() 12345678910public static &lt;T&gt; Observable&lt;T&gt; fromArray(T... items) &#123; ObjectHelper.requireNonNull(items, \"items is null\"); if (items.length == 0) &#123; return empty(); &#125; else if (items.length == 1) &#123; return just(items[0]); &#125; return RxJavaPlugins.onAssembly(new ObservableFromArray&lt;T&gt;(items));&#125; 我们看到fromArray()参数是 可变长度参数，也就是说参数可以为1个，当然了1个时直接调用Observable.just(“文章1”) 一个参数的just()。最后返回一个可变长度参数 items 构造的 ObservableFromArray 对象，他也继承了Observable，也就是说我们创建的被观察着就是 ObservableFromArray 对象。 12345678910111213141516171819public final class ObservableFromArray&lt;T&gt; extends Observable&lt;T&gt; &#123; final T[] array; public ObservableFromArray(T[] array) &#123; this.array = array; &#125; @Override public void subscribeActual(Observer&lt;? super T&gt; observer) &#123; FromArrayDisposable&lt;T&gt; d = new FromArrayDisposable&lt;T&gt;(observer, array); observer.onSubscribe(d); if (d.fusionMode) &#123; return; &#125; d.run(); &#125; ...... 2. 接下来我们看下subscribe方法同样是 123456789101112131415public final void subscribe(Observer&lt;? super T&gt; observer) &#123; try &#123; observer = RxJavaPlugins.onSubscribe(this, observer); subscribeActual(observer); &#125; catch (NullPointerException e) &#123; // NOPMD throw e; &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); RxJavaPlugins.onError(e); npe.initCause(e); throw npe; &#125;&#125; 但是抽象方法subscribeActual()在ObservableFromArray中执行在看ObservableFromArray的subscribeActual()这个方法 123456789101112@Overridepublic void subscribeActual(Observer&lt;? super T&gt; observer) &#123; FromArrayDisposable&lt;T&gt; d = new FromArrayDisposable&lt;T&gt;(observer, array); observer.onSubscribe(d); if (d.fusionMode) &#123; return; &#125; d.run();&#125; 此时创建了FromArrayDisposable对象，参数是我们创建的观察者observer，和传递的可变长度的参数array，然后执行Observer中的onSubscribe()方法。最后执行了FromArrayDisposable的run()方法（注意他不是线程的run()方法）。 我们在看FromArrayDisposable的run()方法 12345678910111213141516171819202122232425262728static final class FromArrayDisposable&lt;T&gt; extends BasicQueueDisposable&lt;T&gt; &#123; final Observer&lt;? super T&gt; downstream; final T[] array; FromArrayDisposable(Observer&lt;? super T&gt; actual, T[] array) &#123; this.downstream = actual; this.array = array; &#125; void run() &#123; T[] a = array; int n = a.length; for (int i = 0; i &lt; n &amp;&amp; !isDisposed(); i++) &#123; T value = a[i]; if (value == null) &#123; downstream.onError(new NullPointerException(\"The \" + i + \"th element is null\")); return; &#125; downstream.onNext(value); &#125; if (!isDisposed()) &#123; downstream.onComplete(); &#125; &#125;&#125; 变量downstream 就是我们创建的观察者 Observer ，array 就是我们传递的可变长度的那一串数组run()方法中遍历array，然后执行回调 downstream.onNext(value) ，最后在执行回调 downstream.onComplete()。 根据上面的分析,我们得出如下规则： 1、通过 just() 方式 直接触发 onNext() 2、just 传进去什么，在onNext() 接收什么，如果我们传入 List，同样的在 onNext() 接收的也是 List，而不是 List 的 Item 3、onNext() 中接收数据的顺序是根据 just 传入的顺序确认的，使用 just 不允许传递 null，否则会出现异常","categories":[{"name":"技术","slug":"技术","permalink":"http://www.wblog.work/categories/技术/"},{"name":"RxJava2","slug":"技术/RxJava2","permalink":"http://www.wblog.work/categories/技术/RxJava2/"}],"tags":[{"name":"Rxjava","slug":"Rxjava","permalink":"http://www.wblog.work/tags/Rxjava/"}]},{"title":"Rxjava2 - Observable示例和源码解析","slug":"Rxjava2-Observable示例和源码解析","date":"2019-10-08T03:21:27.000Z","updated":"2019-10-09T03:12:03.527Z","comments":true,"path":"Rxjava2-Observable示例和源码解析/","link":"","permalink":"http://www.wblog.work/Rxjava2-Observable示例和源码解析/","excerpt":"Observable示例和源码解析","text":"Observable示例和源码解析 示例 123456789101112131415161718192021222324252627282930313233//1、创建一个被观察着(公众号),定义要发送的事件Observable&lt;String&gt; observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; emitter.onNext(\"文章1\"); emitter.onNext(\"文章2\"); emitter.onNext(\"文章3\"); emitter.onComplete(); &#125;&#125;);//2、创建一个观察着（用户），接收事件并作出响应操作Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, \"onSubscribe\"); &#125; @Override public void onNext(String str) &#123; Log.d(TAG, \"onNext : \"+str); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; Log.d(TAG, \"onComplete\"); &#125;&#125;;//建立用户和公众号的订阅关系observable.subscribe(observer); 其实RxJava的核心思想就是观察者模式，只要理解这个，其实RxJava也不难。说白了就是要有观察者和被观察着，然后建立观察者和被观察者之间的关系。 被观察者Observable（公众号）何时创建？ 观察者Observer（用户）何时创建？ 被观察者与观察者如何subscribe（用户关注了公众号）订阅？1. 被观察者Observable类 被观察者Observable为抽象类 实现 ObservableSource接口 12345678public abstract class Observable&lt;T&gt; implements ObservableSource&lt;T&gt; &#123; ... public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) &#123; ObjectHelper.requireNonNull(source, \"source is null\"); return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source)); &#125; ...&#125; 很简单，create方法里面就两行代码，先去判断source的是否为空，然后再去调用RxJavaPlugins.onAssembly(new ObservableCreate(source))，先 new 了 ObservableCreate 类，该类继承了 Observable，然后通过 RxJavaPlugins.onAssembly 方法返回 Observable 对象。 这样 Observable 就创建完成了，其实是创建了 Observable 的子类 ObservableCreate 对象，也就是真实的被观察着对象 12345678910111213141516171819public final class ObservableCreate&lt;T&gt; extends Observable&lt;T&gt; &#123; final ObservableOnSubscribe&lt;T&gt; source; public ObservableCreate(ObservableOnSubscribe&lt;T&gt; source) &#123; this.source = source; &#125; //这个方法很重要，Observable 的 subscribe 其实就执行的这个方法 @Override protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer); observer.onSubscribe(parent); try &#123; source.subscribe(parent); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); parent.onError(ex); &#125; &#125;&#125; 2. 观察者 Observer12345678910public interface Observer&lt;T&gt; &#123; //订阅时回调 void onSubscribe(@NonNull Disposable d); //成功回调 void onNext(@NonNull T t); //错误回调 void onError(@NonNull Throwable e); //完成时回调 void onComplete();&#125; 这个类十分简单，是标准的函数式接口 3. 被观察者与观察者如何subscribe（用户关注了公众号）订阅observable.subscribe(observer); 12345678public final void subscribe(Observer&lt;? super T&gt; observer) &#123; observer = RxJavaPlugins.onSubscribe(this, observer); subscribeActual(observer);&#125; RxJavaPlugins.onSubscribe 此时直接返回Observer观察者对象，最后执行的是 subscribeActual() 方法，我们点进去看看 protected abstract void subscribeActual(Observer&lt;? super T&gt; observer); 是个抽象方法，我们来看看 Observable 子类 ObservableCreate 里面是不是有 subscribeActual(Observer&lt;? super T&gt; observer)，又回到了 ObservableCreate 类。 123456789101112@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer); observer.onSubscribe(parent); try &#123; source.subscribe(parent); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); parent.onError(ex); &#125;&#125; 该方法的参数就是我们创建的观察者 Observer，这里创建了 CreateEmitter 对象，把我们的观察者 Observer 传到 CreateEmitter 的构造方法中。CreateEmitter 类继承了 Disposable 接口： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static final class CreateEmitter&lt;T&gt; extends AtomicReference&lt;Disposable&gt; implements ObservableEmitter&lt;T&gt;, Disposable &#123; final Observer&lt;? super T&gt; observer; CreateEmitter(Observer&lt;? super T&gt; observer) &#123; this.observer = observer; &#125; //最终的回调就是我们创建的观察者 Observer 的 onNext() @Override public void onNext(T t) &#123; if (!isDisposed()) &#123; observer.onNext(t); &#125; &#125; @Override public void onError(Throwable t) &#123; if (!tryOnError(t)) &#123; RxJavaPlugins.onError(t); &#125; &#125; //最终的回调就是我们创建的观察者 Observer 的 onError() @Override public boolean tryOnError(Throwable t) &#123; if (!isDisposed()) &#123; try &#123; observer.onError(t); &#125; finally &#123; dispose(); &#125; return true; &#125; return false; &#125; //最终的回调就是我们创建的观察者 Observer 的 onComplete() @Override public void onComplete() &#123; if (!isDisposed()) &#123; try &#123; observer.onComplete(); &#125; finally &#123; dispose(); &#125; &#125; &#125; ...... &#125; 是不是看到了我们在创建观察者 Observer 时的几个回调方法了， 接下来observer.onSubscribe(parent);这行代码，其实就是我们创建观察者 Observer 时的 public void onSubscribe(Disposable d) 回调 1234567Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, \"onSubscribe\"); &#125; ...... 的参数 Disposable d 就是 CreateEmitter 对象 再看 source.subscribe(parent); 这行代码，这个source就是我们创建被观察者 Observable（其实是它的子类 ObservableCreate）时 new 的 ObservableOnSubscribe，它只有一个 subscribe 方法，执行完这行代码，被观察者与观察者就订阅关系。 那么当我们在执行 1234emitter.onNext(\"文章1\");emitter.onNext(\"文章2\");emitter.onNext(\"文章3\");emitter.onComplete(); 这几行代码的时候，也就是被观察者 Observable 通过CreateEmitter发送事件时，观察者 Observer 就会走相应的回调方法，当此执行完 onComplete() 观察者收到完成回调，整个订阅流程就完成了。 Observable.subscribe()除了接收Observer参数外，还可以接收Consumer参数 示例 1234567891011121314151617181920212223242526272829Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; emitter.onNext(\"文章1\"); emitter.onNext(\"文章2\"); emitter.onNext(\"文章3\"); emitter.onComplete(); &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; Log.d(TAG, \" Consumer : onNext : \" + s); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; Log.d(TAG, \" Consumer : onError\"); &#125; &#125;, new Action() &#123; @Override public void run() throws Exception &#123; Log.d(TAG, \" Action : onComplete\"); &#125; &#125;, new Consumer&lt;Disposable&gt;() &#123; @Override public void accept(Disposable disposable) throws Exception &#123; Log.d(TAG, \" Consumer : onSubscribe\"); &#125; &#125;) 这里我们看到传入的是Consumer，我们来看看这个类： 123public interface Consumer&lt;T&gt; &#123; void accept(T t) throws Exception;&#125; 很简单，就是个普通的接口，里面只有一个accept方法 当使用Consumer作为subscribe()的参数时，最多可以接收4个回调参数，而且执行结果和subscribe(observer)的一样。接下来我们看下Observable的subscribe()方法 123456789101112131415161718192021222324252627282930public final Disposable subscribe() &#123; return subscribe(Functions.emptyConsumer(), Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION, Functions.emptyConsumer());&#125;public final Disposable subscribe(Consumer&lt;? super T&gt; onNext) &#123; return subscribe(onNext, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION, Functions.emptyConsumer());&#125;public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError) &#123; return subscribe(onNext, onError, Functions.EMPTY_ACTION, Functions.emptyConsumer());&#125;public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete) &#123; return subscribe(onNext, onError, onComplete, Functions.emptyConsumer());&#125;public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete, Consumer&lt;? super Disposable&gt; onSubscribe) &#123; ObjectHelper.requireNonNull(onNext, \"onNext is null\"); ObjectHelper.requireNonNull(onError, \"onError is null\"); ObjectHelper.requireNonNull(onComplete, \"onComplete is null\"); ObjectHelper.requireNonNull(onSubscribe, \"onSubscribe is null\"); LambdaObserver&lt;T&gt; ls = new LambdaObserver&lt;T&gt;(onNext, onError, onComplete, onSubscribe); subscribe(ls); return ls;&#125; 有五个重载方法，参数个数0到4个，参数名和接口Observer的方法名一样，从而我们可以猜测处理的事情应该和Observer每个方法的一样。我们看到 当参数少于4个时，就传入空的回调（不是null），那么我们直接看4个参数的subscribe()。 先分别判断参数是否为空，然后通过这个4个参数构造一个 LambdaObserver 对象，最后调用subscribe(ls)，这个subscribe(ls)又是什么呢？我们点进去看看： 123456789101112131415public final void subscribe(Observer&lt;? super T&gt; observer) &#123; try &#123; observer = RxJavaPlugins.onSubscribe(this, observer); subscribeActual(observer); &#125; catch (NullPointerException e) &#123; throw e; &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); RxJavaPlugins.onError(e); npe.initCause(e); throw npe; &#125;&#125; 嗯？似曾相识，对，就是我们认识的那个subscribe，参数就是上面创建的 LambdaObserver 对象，LambdaObserver继承了接口Observer，然后在传入 subscribeActual(observer) ，接下来的流程就和上面一样了。 我们在看 LambdaObserver 类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public final class LambdaObserver&lt;T&gt; extends AtomicReference&lt;Disposable&gt; implements Observer&lt;T&gt;, Disposable, LambdaConsumerIntrospection &#123; private static final long serialVersionUID = -7251123623727029452L; final Consumer&lt;? super T&gt; onNext; final Consumer&lt;? super Throwable&gt; onError; final Action onComplete; final Consumer&lt;? super Disposable&gt; onSubscribe; public LambdaObserver(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete, Consumer&lt;? super Disposable&gt; onSubscribe) &#123; super(); this.onNext = onNext; this.onError = onError; this.onComplete = onComplete; this.onSubscribe = onSubscribe; &#125; //调用观察者的 onSubscribe() @Override public void onSubscribe(Disposable d) &#123; if (DisposableHelper.setOnce(this, d)) &#123; try &#123; onSubscribe.accept(this); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); d.dispose(); onError(ex); &#125; &#125; &#125; //调用观察者的 onNext() @Override public void onNext(T t) &#123; if (!isDisposed()) &#123; try &#123; onNext.accept(t); &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); get().dispose(); onError(e); &#125; &#125; &#125; //调用观察者的 onError() @Override public void onError(Throwable t) &#123; if (!isDisposed()) &#123; lazySet(DisposableHelper.DISPOSED); try &#123; onError.accept(t); &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); RxJavaPlugins.onError(new CompositeException(t, e)); &#125; &#125; else &#123; RxJavaPlugins.onError(t); &#125; &#125; //调用观察者的 onComplete() @Override public void onComplete() &#123; if (!isDisposed()) &#123; lazySet(DisposableHelper.DISPOSED); try &#123; onComplete.run(); &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); RxJavaPlugins.onError(e); &#125; &#125; &#125;&#125; 构造方法里面就是我们传进去的四个参数，而且有四个方法我们似乎也很熟悉，对，他就是接口 Observer 的实现方法。这四个方法中分别执行了四个回调 onSubscribe.accept(Disposable); onNext.accept(T); onError.accept(Throwable); onComplete.run(); 也就是subscribe时传入的回调。","categories":[{"name":"技术","slug":"技术","permalink":"http://www.wblog.work/categories/技术/"},{"name":"RxJava2","slug":"技术/RxJava2","permalink":"http://www.wblog.work/categories/技术/RxJava2/"}],"tags":[{"name":"Rxjava","slug":"Rxjava","permalink":"http://www.wblog.work/tags/Rxjava/"}]},{"title":"EasyUI的对话框（dialog）按钮重复点击的问题","slug":"easyui-repeatclick","date":"2019-09-27T06:21:27.000Z","updated":"2019-09-27T06:47:09.976Z","comments":true,"path":"easyui-repeatclick/","link":"","permalink":"http://www.wblog.work/easyui-repeatclick/","excerpt":"EasyUI的对话框（dialog）按钮重复点击，导致多次请求数据","text":"EasyUI的对话框（dialog）按钮重复点击，导致多次请求数据 第一种实现思路，点击一次后把请求数据的按钮设置为disable 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556$('#mydialog').dialog(&#123; width: 500, height: 250, modal: true, title: 'my dialog', iconCls: 'icon-edit', minimizable: false, closed: true, maximizable: false, buttons: [ &#123; id:\"submit\", text: '确定', iconCls: 'icon-ok', handler: function() &#123; requestData(this); &#125; &#125;, &#123; text: '关闭', iconCls: 'icon-no', handler: function() &#123; $('#mydialog').dialog(\"close\"); &#125; &#125; ], onClose: function() &#123; $(\"#form1\").form(\"clear\"); &#125;&#125;);function requestData(button) &#123; $(button).linkbutton('disable'); //参数 var param=&#123;&#125;; $.ajax(&#123; url: '/api/requestData', type: 'post', data: &#123; param &#125;, dataType: 'json', success: function(res) &#123; $(button).linkbutton('enable'); if (res.IsSuccess) &#123; $.messager.alert(\"提示\", \"操作成功\", \"info\", function() &#123; location.reload(); &#125;); &#125; else &#123; $.messager.alert(\"提示\", res.ErrMsg, \"info\"); &#125; &#125;, error: function() &#123; $(button).linkbutton('enable'); $.messager.alert('提示', '请求出错！', 'error'); &#125; &#125;);&#125; 注意EasyUI的dialog的按钮设置disable和jQuery不一样，jQuery通过$(button).attr(‘disable’:”true”)来设置，但是EasyUI是通过$(button).linkbutton(‘enable’)来设置。 第二种方式，给button设置flag，点击一次后flag设置1，判断flag为1时提示toast 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667$('#mydialog').dialog(&#123; width: 500, height: 250, modal: true, title: 'my dialog', iconCls: 'icon-edit', minimizable: false, closed: true, maximizable: false, buttons: [ &#123; id:\"submit\", text: '确定', iconCls: 'icon-ok', handler: function() &#123; if($('#submit').attr(\"flag\")!=1)&#123; requestData(); &#125;else&#123; $.messager.show(&#123; title:' ', msg:'请不要重复提交', showType:'fade', timeout:1000, style:&#123; &#125; &#125;); &#125; $('#submit').attr(\"flag\", 1); &#125; &#125;, &#123; text: '关闭', iconCls: 'icon-no', handler: function() &#123; $('#mydialog').dialog(\"close\"); &#125; &#125; ], onClose: function() &#123; $(\"#form1\").form(\"clear\"); &#125;&#125;);function requestData() &#123; //参数 var param=&#123;&#125;; $.ajax(&#123; url: '/api/requestData', type: 'post', data: &#123; param &#125;, dataType: 'json', success: function(res) &#123; $('#submit').removeAttr(\"flag\"); if (res.IsSuccess) &#123; $.messager.alert(\"提示\", \"操作成功\", \"info\", function() &#123; location.reload(); &#125;); &#125; else &#123; $.messager.alert(\"提示\", res.ErrMsg, \"info\"); &#125; &#125;, error: function() &#123; $('#submit').removeAttr(\"flag\"); $.messager.alert('提示', '请求出错！', 'error'); &#125; &#125;);&#125; 参考EasyUI官网：http://www.jeasyui.com/documentation/index.php#","categories":[{"name":"技术","slug":"技术","permalink":"http://www.wblog.work/categories/技术/"},{"name":"前端","slug":"技术/前端","permalink":"http://www.wblog.work/categories/技术/前端/"}],"tags":[{"name":"js","slug":"js","permalink":"http://www.wblog.work/tags/js/"},{"name":"EasyUI","slug":"EasyUI","permalink":"http://www.wblog.work/tags/EasyUI/"}]},{"title":"HTML select的onchange()事件不触发","slug":"HTML-selecton-change","date":"2019-09-27T03:21:27.000Z","updated":"2019-09-27T06:50:31.770Z","comments":true,"path":"HTML-selecton-change/","link":"","permalink":"http://www.wblog.work/HTML-selecton-change/","excerpt":"最近在帮后端修改bug，本来对js 只是熟悉，没有达到深入的层次，今天遇到了一个select的onchange()事件不触发的问题，记录一下，以备后续需要。","text":"最近在帮后端修改bug，本来对js 只是熟悉，没有达到深入的层次，今天遇到了一个select的onchange()事件不触发的问题，记录一下，以备后续需要。 下面是代码： 1234567891011121314151617//省去无关代码&lt;select onchange=\"fun()\" id=\"CategoryName\" class=\"easyui-combobox\" editable=\"false\"&gt; &lt;option value=\"\"&gt;全部&lt;/option&gt; @foreach (var item in noticeCategoryGroup) &#123; &lt;option value=\"@item.Key\"&gt;@item.Value&lt;/option&gt; &#125;&lt;/select&gt;//省去无关代码&lt;script&gt; function fun()&#123; alert(1); &#125;&lt;/script&gt; 上面代码中死活不能触发onchange，各种百度，都是这样写的，又试了下面这种方式： 123$('#CategoryName').change(function(data)&#123; alert(1);&#125;) 还是不行，奇了怪了。在仔细一看会不会是 easyui-combobox在捣鬼。 于是又搜easyui-combobox的onchange()的事件，果然是！ 12345$('#CategoryName').combobox(&#123; onChange:function(n,o)&#123; alert(1); &#125; &#125;); n代表选中的新值，o代表上一个值。 下面是easyui-combobox的所有事件： 参考EasyUI官网：http://www.jeasyui.com/documentation/index.php#","categories":[{"name":"技术","slug":"技术","permalink":"http://www.wblog.work/categories/技术/"},{"name":"前端","slug":"技术/前端","permalink":"http://www.wblog.work/categories/技术/前端/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://www.wblog.work/tags/HTML/"},{"name":"js","slug":"js","permalink":"http://www.wblog.work/tags/js/"},{"name":"EasyUI","slug":"EasyUI","permalink":"http://www.wblog.work/tags/EasyUI/"}]},{"title":"Rxjava2 - RxScheduler示例和详细解析","slug":"rxjava-schedul","date":"2019-09-25T03:21:27.000Z","updated":"2019-09-27T01:42:14.607Z","comments":true,"path":"rxjava-schedul/","link":"","permalink":"http://www.wblog.work/rxjava-schedul/","excerpt":"概述首先了解 Schedulers 和 Scheduler 的概念Scheduler 是负责执行任务的单元, 调度器，相当于线程控制器，RxJava 通过它来指定每一段代码应该运行在什么样的线程，而 Schedulers 是创建各种 Scheduler 的工厂，Schedulers.io()等等都返回的是 Scheduler。","text":"概述首先了解 Schedulers 和 Scheduler 的概念Scheduler 是负责执行任务的单元, 调度器，相当于线程控制器，RxJava 通过它来指定每一段代码应该运行在什么样的线程，而 Schedulers 是创建各种 Scheduler 的工厂，Schedulers.io()等等都返回的是 Scheduler。 我们可以使用使用 subscribeOn() 和 observeOn() 两个方法来对线程进行控制。比如常用的 Observable 生成发射数据流，以及 Operators 加工数据流都是在后台线程中进行，而 Observer 在前台线程中接受并相应数据。 subscribeOn() 和 observeOn() subscribeOn(): 指定 ObservableOnSubscribe#subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程，我把他叫做上游。当调用多次 subscribeOn() 时，事件产生会运行在最早的一次调用声明的线程中。当然也不是说多次的调用是完全没效果的，后面会提到。 observeOn(): 指定 Observer 所运行在的线程。或者叫做事件消费的线程，我把他叫做下游。每次调用 observeOn() 都会发生线程切换，此次调用直到下次切换线程中间的过程中的操作运行在此次调用指定的线程中。 RxJava 提供了以下这些调度器： Schedulers.single();运行在一个单独的线程，顺序执行，先进先出 Schedulers.computation();计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算；默认线程数等于处理器的数量。 不要执行阻塞、IO操作(IO操作请使用Schedulers.io()) Schedulers.io();I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程 Schedulers.trampoline();在当前线程立即执行任务，如果当前线程有任务在执行，则会将其暂停，等插入进来的任务执行完之后，再将未完成的任务接着执行 Schedulers.newThread();总是启用新线程，并在新线程执行操作 Schedulers.from(@NonNull Executor executor);使用指定的 Executor 作为调度器 AndroidSchedulers.mainThread();它指定的操作将在 Android 主线程运行 示例以下示例部分参考：https://www.jianshu.com/p/12638513424f自己再敲一遍，有助于更深层的理解 示例1 使用一次subscribeOn和一次observeOn： 123456789101112Observable .create((ObservableOnSubscribe&lt;Integer&gt;) emitter -&gt; &#123; for (int i =1;i&lt;3;i++)&#123; System.out.println(\"发射线程：\"+Thread.currentThread().getName()+\"----&gt;\"+\"发射：\"+i); Thread.sleep(1000); emitter.onNext(i); &#125; emitter.onComplete(); &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(integer -&gt; System.out.println(\"接收线程：\"+Thread.currentThread().getName()+\"----&gt;\"+\"接收：\"+integer))); 打印日志： 1234发射线程：RxCachedThreadScheduler-1----&gt;发射：1发射线程：RxCachedThreadScheduler-1----&gt;发射：2接收线程：main----&gt;接收：1接收线程：main----&gt;接收：2 可以看出 上游数据发射在 RxCachedThreadScheduler-1 中执行，也就是IO线程中执行，下游接收是在主线程main中 示例2 使用两次 subscribeOn 和一次 observeOn： 123456789101112131415161718Observable .create((ObservableOnSubscribe&lt;Integer&gt;) emitter -&gt; &#123; for (int i =1;i&lt;3;i++)&#123; System.out.println(\"发射线程：\"+Thread.currentThread().getName()+\"----&gt;\"+\"发射：\"+i); Thread.sleep(1000); emitter.onNext(i); &#125; emitter.onComplete(); &#125;) .subscribeOn(Schedulers.io()) .map(integer -&gt; &#123; System.out.println(\"处理线程：\"+Thread.currentThread().getName()+\"----&gt;\"+\"处理：\"+integer); return integer; &#125;) .subscribeOn(Schedulers.newThread())//这次设置线程没起作用 .observeOn(AndroidSchedulers.mainThread()) .subscribe(integer -&gt; System.out.println(\"接收线程：\"+Thread.currentThread().getName()+\"----&gt;\"+\"接收：\"+integer)); 打印日志： 123456发射线程：RxCachedThreadScheduler-1----&gt;发射：1处理线程：RxCachedThreadScheduler-1----&gt;处理：1接收线程：main----&gt;接收：1发射线程：RxCachedThreadScheduler-1----&gt;发射：2处理线程：RxCachedThreadScheduler-1----&gt;处理：2接收线程：main----&gt;接收：2 可以看出 数据的接收是在主线程（main）中，但是发射和处理都在 RxCachedThreadScheduler-1 中执行，也就是IO线程中执行，而我们设置的 subscribeOn(Schedulers.newThread() 没起作用 示例3使用一次 subscribeOn 和两次 observeOn： 1234567891011121314151617Observable .create((ObservableOnSubscribe&lt;Integer&gt;) emitter -&gt; &#123; for (int i =1;i&lt;3;i++)&#123; System.out.println(\"发射线程：\"+Thread.currentThread().getName()+\"----&gt;\"+\"发射：\"+i); Thread.sleep(1000); emitter.onNext(i); &#125; emitter.onComplete(); &#125;) .subscribeOn(Schedulers.io()) .observeOn(Schedulers.newThread()) .map(integer -&gt; &#123; System.out.println(\"处理线程：\"+Thread.currentThread().getName()+\"----&gt;\"+\"处理：\"+integer); return integer; &#125;) .observeOn(AndroidSchedulers.mainThread()) .subscribe(integer -&gt; System.out.println(\"接收线程：\"+Thread.currentThread().getName()+\"----&gt;\"+\"接收：\"+integer))); 打印日志： 123456发射线程：RxCachedThreadScheduler-1----&gt;发射：1发射线程：RxCachedThreadScheduler-1----&gt;发射：2处理线程：RxNewThreadScheduler-1----&gt;处理：1接收线程：main----&gt;接收：1处理线程：RxNewThreadScheduler-1----&gt;处理：2接收线程：main----&gt;接收：2 可以看出发射线程在 RxCachedThreadScheduler-1 (IO线程) 中，数据的处理在 RxNewThreadScheduler-1 (也就是Schedulers.newThread())中，数据的接收在 主线程main中。说明 Observeon 每次设置都会起作用 示例4：doOnSubscribe()/onSubscribe()，doOnNext()/onNext()，doOnComplete()/onComplete()，doOnError()/onError() 1234567891011121314151617181920212223242526272829303132333435363738394041424344System.out.println(\"当前线程----&gt;\" + Thread.currentThread().getName());mDisposables.add(Observable .create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; System.out.println(\"Observable线程----&gt;\" + Thread.currentThread().getName()); e.onNext(10); e.onComplete(); &#125; &#125;) // 从上面demo中可知 Observable 会在计算线程中执行 .subscribeOn(Schedulers.computation()) // 预测1：observeOn切换到线程，doOnSubscribe 在 NewThread-1 线程 .observeOn(Schedulers.newThread()) .doOnSubscribe(new Consumer&lt;Disposable&gt;() &#123; @Override public void accept(@NonNull Disposable disposable) throws Exception &#123; System.out.println(\"doOnSubscribe线程----&gt;\" + Thread.currentThread().getName()); &#125; &#125;) // 预测2：observeOn切换到线程，doOnNext 在 NewThread-2 线程 .observeOn(Schedulers.newThread()) .doOnNext(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; System.out.println(\"doOnNext线程----&gt;\" + Thread.currentThread().getName()); &#125; &#125;) // 预测3：observeOn切换到线程，doOnComplete 在 NewThread-3 线程 .observeOn(Schedulers.newThread()) .doOnComplete(new Action() &#123; @Override public void run() throws Exception &#123; System.out.println(\"doOnComplete线程----&gt;\" + Thread.currentThread().getName()); &#125; &#125;) // 预测4：observeOn切换到线程，subscribe 在 NewThread-4 线程 .observeOn(Schedulers.newThread()) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; System.out.println(\"subscribe线程----&gt;\" + Thread.currentThread().getName()); &#125; &#125;)); 打印日志： 123456当前线程----&gt;maindoOnSubscribe线程----&gt;mainObservable线程----&gt;RxComputationThreadPool-1doOnNext线程----&gt;RxNewThreadScheduler-2doOnComplete线程----&gt;RxNewThreadScheduler-3subscribe线程----&gt;RxNewThreadScheduler-4 可以看出我们预测2/3/4点都正确，doOnNext()、doOnComplete()、subscribe都在指定的newThread中，但是预测1却在主线程，说明 observeOn() 不能切换doOnSubscribe()。 我们再做个这样的测试，把整段代码放在新的 Thread 中执行 1234567891011121314151617181920212223242526272829303132//新建一个ThreadThread thread = new Thread()&#123; @Override public void run() &#123; System.out.println(\"当前线程----&gt;\" + Thread.currentThread().getName()); mDisposables.add(Observable .create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; System.out.println(\"Observable线程----&gt;\" + Thread.currentThread().getName()); e.onNext(10); e.onComplete(); &#125; &#125;) .subscribeOn(Schedulers.computation()) .doOnSubscribe(new Consumer&lt;Disposable&gt;() &#123; @Override public void accept(@NonNull Disposable disposable) throws Exception &#123; System.out.println(\"doOnSubscribe线程----&gt;\" + Thread.currentThread().getName()); &#125; &#125;) .observeOn(Schedulers.newThread()) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; System.out.println(\"subscribe线程----&gt;\" + Thread.currentThread().getName()); &#125; &#125;)); &#125;&#125;;//启动线程thread.start(); 输入日志： 1234当前线程----&gt;Thread-282doOnSubscribe线程----&gt;Thread-282Observable线程----&gt;RxComputationThreadPool-1subscribe线程----&gt;RxNewThreadScheduler-1 看来doOnSubscribe比较特殊，它默认运行在执行该段代码的线程中，我们再用subscribeOn() 切换了线程试试： 12345678910// 预测1、observeOn切换到线程，doOnSubscribe 在 NewThread 线程，切换无效// .observeOn(Schedulers.newThread()).doOnSubscribe(new Consumer&lt;Disposable&gt;() &#123; @Override public void accept(@NonNull Disposable disposable) throws Exception &#123; System.out.println(\"doOnSubscribe线程----&gt;\" + Thread.currentThread().getName()); &#125;&#125;)//subscribeOn 切换线程，doOnSubscribe 会不会在 io 线程呢？.subscribeOn(Schedulers.io()) 输入日志： 123456当前线程----&gt;maindoOnSubscribe线程----&gt;RxCachedThreadScheduler-1Observable线程----&gt;RxComputationThreadPool-1doOnNext线程----&gt;RxNewThreadScheduler-1doOnComplete线程----&gt;RxNewThreadScheduler-2subscribe线程----&gt;RxNewThreadScheduler-3 我们看到用 subscribeOn(Schedulers.io()) 切换到了 IO 线程 对于 doOnNext()/onNext()，doOnComplete()/onComplete()，doOnError()/onError() 几个方法 (前者是 被观察者 调用的方法，后者是 观察者 接口里面的对应方法) ，可以通过 observeOn() 进行线程的切换。 而对于 doOnSubscribe()/onSubscribe() 方法 (前者是 被观察者 调用的方法，后者是 观察者 接口里面的对应方法) 来说，如果他后面有调用 subscribeOn() 切换线程，那么它运行在切换的线程，否则他默认运行在执行该段代码的线程中 示例5 Schedulers.trampoline()： 通过上面示例我们可以发现，Observer处理数据相比于Observable发射的数据存在滞后的现象，Observable发射了两个数据，Observer才处理了一个，并不是Observable每发射一个，Observer就处理一个。 1234567891011121314151617Observable .create((ObservableOnSubscribe&lt;Integer&gt;) emitter -&gt; &#123; for (int i = 1; i &lt; 3; i++) &#123; System.out.println(\"发射线程：\" + Thread.currentThread().getName() + \"----&gt;\" + \"发射：\" + i); Thread.sleep(1000); emitter.onNext(i); &#125; emitter.onComplete(); &#125;) .subscribeOn(Schedulers.io()) .observeOn(Schedulers.trampoline()) // .subscribeOn(Schedulers.trampoline()) // .observeOn(Schedulers.trampoline()) .subscribe(integer -&gt; &#123; Thread.sleep(2000); System.out.println(\"接收线程：\" + Thread.currentThread().getName() + \"----&gt;\" + \"接收：\" + integer); &#125;) 打印日志： 1234发射线程：RxCachedThreadScheduler-1----&gt;发射：1接收线程：RxCachedThreadScheduler-1----&gt;接收：1发射线程：RxCachedThreadScheduler-1----&gt;发射：2接收线程：RxCachedThreadScheduler-1----&gt;接收：2 可以看到日志是按 发射-&gt;处理-&gt;接收 的顺序打印的，说明 Observable 在 Observer 将数据处理完之后才开始发射下一条。Schedulers.trampoline() 的作用 在当前线程（当前线程是IO线程）立即执行任务，如果当前线程有任务在执行，则会将其暂停，等插入进来的任务执行完之后，再将未完成的任务接着执行。 我们这样改下： 1234 // .subscribeOn(Schedulers.io()) // .observeOn(Schedulers.trampoline()).subscribeOn(Schedulers.trampoline()).observeOn(Schedulers.trampoline()) 打印日志： 1234发射线程：main----&gt;发射：1接收线程：main----&gt;接收：1发射线程：main----&gt;发射：2接收线程：main----&gt;接收：2 我们都注释掉： 1234 // .subscribeOn(Schedulers.io()) // .observeOn(Schedulers.trampoline())// .subscribeOn(Schedulers.trampoline())// .observeOn(Schedulers.trampoline()) 打印日志： 1234发射线程：main----&gt;发射：1接收线程：main----&gt;接收：1发射线程：main----&gt;发射：2接收线程：main----&gt;接收：2 和上面一样说明 Schedulers.trampoline() 是作用当前主线程main上，相当于不指定线程。 示例6 Schedulers.single()： 12345678910111213141516171819Observable .create((ObservableOnSubscribe&lt;Integer&gt;) emitter -&gt; &#123; for (int i = 1; i &lt; 3; i++) &#123; System.out.println(\"发射线程：\" + Thread.currentThread().getName() + \"----&gt;\" + \"发射：\" + i); Thread.sleep(1000); emitter.onNext(i); &#125; emitter.onComplete(); &#125;) .subscribeOn(Schedulers.single()) .observeOn(Schedulers.single()) .map(integer -&gt; &#123; System.out.println(\"处理线程：\" + Thread.currentThread().getName() + \"----&gt;\" + \"处理：\" + integer); return integer; &#125;) .observeOn(Schedulers.single()) .subscribe(integer -&gt; &#123; System.out.println(\"接收线程：\" + Thread.currentThread().getName() + \"----&gt;\" + \"接收：\" + integer); &#125;) 打印日志： 123456发射线程：RxSingleScheduler-1----&gt;发射：1发射线程：RxSingleScheduler-1----&gt;发射：2处理线程：RxSingleScheduler-1----&gt;处理：1处理线程：RxSingleScheduler-1----&gt;处理：2接收线程：RxSingleScheduler-1----&gt;接收：1接收线程：RxSingleScheduler-1----&gt;接收：2 通过Schedulers.single()将数据的发射，处理，接收在Schedulers.single()的线程单例中排队执行，当此线程中有任务执行时，其他任务将会按照先进先出的顺序依次执行。 下面举个完整的示例，需求是这样的： （1）在io线程请求服务器数据； （2）请求之前需要在主线程显示 Loading dialog； （3）数据返回后在 computation() 处理； （4）处理完成后在 io() 存入数据库； （5）主线程 更新UI； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Observable .create(new ObservableOnSubscribe&lt;List&lt;String&gt;&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;List&lt;String&gt;&gt; emitter) throws Exception &#123; System.out.println(\"IO线程----&gt;发起网络请求，请求服务器数据\"); // TODO: 2019/8/23 请求网络 List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i=0;i&lt;10;i++)&#123; list.add(\"数据\"+i); &#125; emitter.onNext(list); emitter.onComplete(); &#125; &#125;) .subscribeOn(Schedulers.io()) .doOnSubscribe(new Consumer&lt;Disposable&gt;() &#123; @Override public void accept(Disposable disposable) throws Exception &#123; System.out.println(\"UI主线程----&gt;显示 Loading dialog\"); &#125; &#125;) .subscribeOn(AndroidSchedulers.mainThread()) .observeOn(Schedulers.computation()) .filter(new Predicate&lt;List&lt;String&gt;&gt;() &#123; @Override public boolean test(List&lt;String&gt; list) throws Exception &#123; //list 从服务器请求的数据 System.out.println(\"计算线程处理----&gt;处理数据\"); return true; &#125; &#125;) .observeOn(Schedulers.io()) .doOnNext(new Consumer&lt;List&lt;String&gt;&gt;() &#123; @Override public void accept(List&lt;String&gt; filterList) throws Exception &#123; //filterList 处理后的数据 System.out.println(\"IO线程----&gt;存入数据库\"); &#125; &#125;) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;List&lt;String&gt;&gt;() &#123; @Override public void accept(List&lt;String&gt; list) throws Exception &#123; //str 处理之后的数据 System.out.println(\"UI主线程----&gt;显示数据更新UI\"); &#125; &#125;) 打印日志： 12345UI主线程----&gt;显示 Loading dialogIO线程----&gt;发起网络请求，请求服务器数据计算线程处理----&gt;处理数据IO线程----&gt;存入数据库UI主线程----&gt;显示数据更新UI 通过以上示例，我们可以总结subscribeOn和observeOn的用法如下: subscribeOn 用来声明上游事件发送时的所在线程，若多次设定，上游会运行在 最早 的一次调用声明的线程中。observeOn 指定下游操作所在的线程。若多次设定，每次均起作用。如若不指定下游线程，则默认在上游所在的线程中","categories":[{"name":"技术","slug":"技术","permalink":"http://www.wblog.work/categories/技术/"},{"name":"RxJava2","slug":"技术/RxJava2","permalink":"http://www.wblog.work/categories/技术/RxJava2/"}],"tags":[{"name":"Rxjava","slug":"Rxjava","permalink":"http://www.wblog.work/tags/Rxjava/"}]},{"title":"【转】Java注解基础学习","slug":"annotation","date":"2019-09-20T01:21:27.000Z","updated":"2019-09-27T02:13:56.325Z","comments":true,"path":"annotation/","link":"","permalink":"http://www.wblog.work/annotation/","excerpt":"其实同class和interface一样，注解也属于一种类型。它是在Java SE 5.0版本中开始引入的概念。","text":"其实同class和interface一样，注解也属于一种类型。它是在Java SE 5.0版本中开始引入的概念。 注解的定义注解通过 @ interface 关键字进行定义。 123public @interface TestAnnotation &#123;&#125; 它的形式跟接口很类似，不过前面加了@符号。 上面的代码就创建了一个名字为TestAnnotation的注解。 可以简单理解为创建了一张名字为TestAnnotation的标签 注解的应用上面创建了一个注解，那么注解怎么使用呢？ 1234@TestAnnotationpublic class Test &#123;&#125; 创建一个类 Test，然后在类上面加上 @ TestAnnotation 就可以用。你可以简单理解为将 TestAnnotation 这个张标签贴到Test这个类上面。 不过，想要注解能够正常工作，还需介绍一下 元注解。 元注解元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其他的注解上面。 如果难于理解的话，可以这样理解。元注解就是一种标签，但是它是一张特殊的标签，它的作用和目的就是给其他普通的标签进行解释说明的。 元注解有 @Retention、 @Documented、 @Target、 @Inherited、 @Repeatable 5种。 @RetentionRetention的英文意为保留期的意思。当@Retention 引用到一个注解上的时候，它解释了这个注解的存活时间。 源码如下： 123456@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Retention &#123; RetentionPolicy value();&#125; 从源码可以看出，其有一个属性value，返回一个枚举 RetentionPolicy 类型，有3种类型： RetentionPolicy.SOURCE： 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽略。 RetentionPolicy.CLASS：注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。 RetentionPolicy.RUNTIME：注解可以保留到程序运行的时候，它会被加载进入到JVM中，所以在程序运行时可以获取到它们。 我们可以通过这样的方式类加深理解，@Retention 去给一张标签解释的时候，它指定了这张标签的时间。@Retention相当于给一张标签上面盖了一张时间戳，时间戳指明了标签张贴的时间周期。 1234@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation&#123;&#125; 上面的代码中，我们指定了TestAnnotation 可以在程序运行周期被获取到，因次它的生命周期非常长。 @Document顾名思义，这个元注解肯定和文档有关。它的作用是能够将注解中的元素包含到Javadoc中取。 @TargetTarget是目标的意思，@Target指定了注解运用的地方。也就是指明，你的注解到底是用来修饰方法的？修饰类的？还是用来修饰字段属性的。 123456@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Target &#123; ElementType[] value();&#125; 从源码中可以看出，其有一个属性value，返回一个枚举 ElementType 类型的数组，这个数组的值就代表了可以在那些场景。 1234567891011121314151617181920212223242526272829303132333435public enum ElementType &#123; /** 允许被修饰的注解作用在类、接口和枚举上 */ TYPE, /** 允许作用在属性字段上，包括enum实例 */ FIELD, /** 允许作用在方法上 */ METHOD, /** 允许作用在方法参数上 */ PARAMETER, /** 允许作用在构造器上 */ CONSTRUCTOR, /** 允许作用在局部变量上 */ LOCAL_VARIABLE, /** 允许作用在注解上(应用于另一个注解上) */ ANNOTATION_TYPE, /** 允许作用在包上 */ PACKAGE, /** * 允许作用在类型参数声明（1.8新加入） */ TYPE_PARAMETER, /** * 允许作用在类型使用声明（1.8新加入) */ TYPE_USE&#125; 例如 @Override 注解使用了@Target(ElementType.METHOD)，意味着，它只能注解方法，不能注解属性或者类，或者其他情况。当未指定Target值时，则可以用于任何元素上，多个值则使用{}包含并用 “,”隔开，比如：@Target(value={CONSTRUCTOR,FIELD,METHOD}该注解既可注解构造方法、字段和方法。 @InheritedInherited是继承的意思，其让被修饰的注解拥有被继承的能力。 一个被@Inherited注解了的注解 修饰了一个父类，如果他的子类没有被其他注解修饰，则他的子类也继承了父类的注解。 1234567891011121314151617181920212223242526/** 自定义注解*/@Inherited@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface TestAnnotation&#123;&#125;/** 父类标注 自定义注解 */@TestAnnotationpublic class Father&#123;&#125;/** 子类 */public class Son extentx Father&#123;&#125;/** 测试子类获取父类自定义注解*/public class Test&#123; public static void main(String[] args)&#123; //获取Son的class对象 Class&lt;Son&gt; sonClass = Son.class; //获取Son类上的注解TestAnnotation可以执行成功 TestAnnotation annotation = sonClass.getAnnotation(TestAnnotation.class); &#125;&#125; 注解TestAnnotation被@Inherited修饰，之后类Father被TestAnnotation注解，类Son继承了Father类，类Son也就拥有TestAnnotation这个注解。 可以这样理解： 老子非常有钱，所以人们给他贴了一张标签叫做富豪。 老子的儿子长大后，只要没和老子断绝父子关系，虽然别人没给他贴富豪的标签，但他自然也是富豪。 老子的孙子长大后，自然也是富豪。 这就是人们口中戏称的富一代，富二代，富三代。虽然叫法不同，好像好多个标签，但其实事情的本质也就是他们有一张共同的标签，也就是老子身上的那张富豪的标签。 @RepeatableRepeatable是可重复的意思，@Repeatable是Java1.8才加进来的，所有算是一个新的特效。 别这个元注解修饰的注解 可以多次修饰同一个对象，但是每次注解又代表不同的含义。比如：一个人既是程序员，又是成品经理，同时也是画家 1234567891011121314151617/** 定义一个容器注解*/@interface Persons&#123; Person[] value();&#125;/** 被Repeatable修饰的注解 */@Repeatable(Persons.class)@interface Person&#123; String role() default \"\";&#125;@Person(role=\"artist\")@Person(role=\"coder\")@Person(role=\"PM\")class SuperMan&#123; &#125; 上面的代码@Repeatable注解了Person。而@Repeatable后面括号中的类相当于一个容器注解。 什么是容器注解呢？就是存放其他注解的地方。他本身也是一个注解。 容器注解，他里面必须要有一个value的属性，注意它是数组。 如果不好理解的话，可以这样理解。Persons 是一张总的标签，上面贴满了Person这种类型但内容不一样的标签。把Person给SuperMan贴上，相当于同时给他贴上了程序员、产品经理、画家的标签。 我们可能对于@Person(role=”PM”) 括号里的内容感兴趣，他其实就是Person这个注解的role属性赋值为PM。 注解的属性注解的属性也叫做成员变量。注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。 注解本质上就是一个Annotation接口 1234567891011/** Annotatioin 接口源码*/public interface Annotation&#123; boolean equals（Object obj; int hashCode(); String toString(); Class&lt;? extends Annotation&gt; annotationType();&#125; 通过以上源码，我们知道注解本身就是Annotation接口的子接口，也就是说注解其实可以有属性和方法，但是接口的数据都是static final的，对于注解来说没有什么意义，而我们定义的接口方法就相当于是注解的属性，也就对应了前面所说的为什么注解只有属性成员变量，其实他就是接口的方法，这就为什么成员变量会有方法，不同于接口的是我们可以在注解的括号中给成员变量赋值。 123456789@Target(ElementType.TYPE)@Retention(RetentioniPolicy.RUNTIME)public @interface TestAnnotation&#123; String name() default \"zk\"; int age() default 18;&#125;@TestAnnotation(name=\"zhangke\",age=\"25\")public class Person&#123;&#125; 上面代码定义了TestAnnotation 这个注解拥有name和age两个属性。用default 指定默认值。如果有default设置了默认值时，也可以无需在TestAnnotation后面的括号中进行赋值。 123@TestAnnotation()public class Person&#123;&#125; 赋值的方式就是在注解的括号中用“,”隔开分别给对应的属性赋值。如果注解的只有一个属性时，可以直接把属性值写到括号中。 12345678@Target(ElementType.TYPE)@Retention(RetentioniPolicy.RUNTIME)public @interface TestAnnotation&#123; String name();&#125;@TestAnnotation(zhangke)public class Person&#123;&#125; 需要注意的是，在注解中定义属性时有一下几种的类型：1、基本数据类型2、String3、枚举4、注解5、类、接口6、以上类型的一维数组类型 Java 内置的注解Java内置的直接共有5个@Override：这个大家很熟悉了，让编译器检查被标记的方法，保证其重写了父类的某一个方法。此注解只能标记方法。 1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125; @Deprecated：标记某些程序元素已经过时，程序员请不要再使用了 12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)public @interface Deprecated &#123;&#125; @SuppressWarnings：阻止警告的意思。调用了被@Deprecated注解后的方法，编译器会警告提醒，但是开发者不想看到这些警告，可以使用@SuppressWarnings达到目的 12345@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings &#123; String[] value();&#125; 其内部有个String数组类型的属性，根据传入的值来取消相应的警告：deprecation：使用了不赞成使用的类或方法时的警告；unchecked：执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型;fallthrough：当 Switch 程序块直接通往下一种情况而没有 Break 时的警告;path：在类路径、源文件路径等中有不存在的路径时的警告;serial：当在可序列化的类上缺少 serialVersionUID 定义时的警告;finally：任何 finally 子句不能正常完成时的警告;all：关于以上所有情况的警告 @SafeVarargs(Java7 新增)：@SuppressWarnings可以用在各种需要取消警告的地方，而 @SafeVarargs主要用在取消参数的警告。就是说编译器如果检查到你对方法参数的操作，有可能发生问题时会给出警告，但是你很自（任）性，老子不要警告，于是你就加上了这个标签。 1234@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD&#125;)public @interface SafeVarargs &#123;&#125; @FunctionalInterface(Java8 新增)：标记型注解，告诉编译器检查被标注的接口是否是一个函数接口，即检查这个接口是否只包含一个抽象方法，只有函数接口才可以使用Lambda表达式创建实例。 如何使用注解前面我们学习了注解的基本语法，那注解具体怎么使用呢？这时候就需要用到APT（Annotation Processing Tool），访问和处理Annotation的工具，那么APT是具体怎么读取注解的属性信息的呢，那就是反射。Annotation接口是所有注解的父接口（需要通过发编译查看），在java.lang.reflect发射包下存在一个叫AnnotationElement的接口，其表示程序中可以接受注解的程序元素，比如类，方法，字段，构造方法，包等等。而Java为使用反射的主要类实现了此接口，如Class类、Field类、Method类、Constructor类等。 当我们通过反射技术获取到反射包内的那些类型的实例后，就可以通过AnnotationElement接口的API方法来获取注解信息了。 1234567891011121314151617/**是否存在对应 Annotation 对象*/ public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) &#123; return GenericDeclaration.super.isAnnotationPresent(annotationClass); &#125;/**获取 Annotation 对象*/ public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) &#123; Objects.requireNonNull(annotationClass); return (A) annotationData().annotations.get(annotationClass); &#125;/**获取所有 Annotation 对象数组*/ public Annotation[] getAnnotations() &#123; return AnnotationParser.toArray(annotationData().annotations); &#125; 下面结合前面的例子，我们来获取下注解的属性，在获取之前我们自定义的注解必须使用元注解@Retention(RetentionPolicy.RUNTIME)。 待续…","categories":[{"name":"技术","slug":"技术","permalink":"http://www.wblog.work/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"http://www.wblog.work/categories/技术/Java/"},{"name":"反射和注解","slug":"技术/Java/反射和注解","permalink":"http://www.wblog.work/categories/技术/Java/反射和注解/"}],"tags":[{"name":"注解","slug":"注解","permalink":"http://www.wblog.work/tags/注解/"}]},{"title":"【转】java反射基础学习（附demo）","slug":"reflection","date":"2019-09-20T01:21:27.000Z","updated":"2019-09-27T02:11:16.992Z","comments":true,"path":"reflection/","link":"","permalink":"http://www.wblog.work/reflection/","excerpt":"Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有的属性和方法；对于任意一个对象，都能够调用它的任何方法和属性；","text":"Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有的属性和方法；对于任意一个对象，都能够调用它的任何方法和属性； 也就是说反射机制在程序运行的过程中，能够获取任何已知名称的类的内部信息，并在执行过程中，动态生成对象实体、对fields设值、或者调用methods。 这种在程序运行过程中，动态获取类的信息以及动态调用方法的功能称为Java的反射机制。 Reflection API 简介在JDK中，主要由一下类来实现Java反射机制，这些类（出来Class）都位于java.lang.reflect包中。 类名 含义 Class 类 代表某个具体的类和接口，位于java.lang包下 Field类 代表类的成员变量（成员变量也称为类的属性） Method类 代表类或者接口上的方法 Constructor类 代表类的构造方法 Array类 提供了动态创建数组，以及访问数组的元素的静态方法 Class类Class本身就是一个类，Class是该类的名称，注意不要理解成类类型。 1public class MyTest&#123;&#125; 注意上面的class的首字母是小写的，他表示一中类类型，但是Class是一个类，相当于上面定义的MyTest类。 在Java中，每个class都有一个相应的Class对象，也就是说，当我们编写一个类，编译成.class文件后，就会产生一个Class对象，用于表达这个类的类型信息。无论某个类有多少个对象，这些对象都会对应同一个Class对象。 Class的获取方式： 使用Class类的静态方法 1Class&lt;?&gt; testClazz01 = Class.forName(\"com.zwb.MyTest\"); 使用类的.class 1Class&lt;? extends MyTest&gt; testClazz02 = MyTest.class; 使用对象的getClass()方法 12MyTest myTest = new MyTest();Class&lt;? extends MyTest&gt; testClazz03 = myTest.getClass(); Class相关的方法 获得类相关的方法 方法名 含义 asSubClass(Class clazz) 把传递的类的对象转换成代表其子类的对象 Cast 把对象转换成代表类或者接口的对象 getClassLoader() 获得类的加载器 getClasses() 返回一个数组，数组中包含该类中所有具有public属性的类和接口类的对象 getDeclaredClasses() 返回一个数组，数组中包含该类中所有类和接口类的对象 forName(String className) 根据类名返回类的对象 getName() 获得类的完整路径名字 newInstance() 创建类的实例 getPackage 获取类的包 getSimpleName 获取类的名字 getSuperclass 获取父类的名字 getInterfaces 获取当前类实现的接口 示例 获得类中构造器相关的方法 方法 含义 getConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的公有构造方法 getConstructors() 获得该类的所有公有构造方法 getDeclaredConstructors(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的构造方法 getDeclaredConstructors() 获得该类所有构造方法 示例 获得类中方法相关的方法 方法 含义 getMethod(String name, Class…&lt;?&gt; parameterTypes) 根据方法名和参数，返回一个具体的具有public属性的方法 getMethods() 返回所有具有public属性的方法数组（包括从父类继承的public方法和实现接口的public方法） getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes) 根据方法名和参数，返回一个具体的方法（不分public和非public属性） getDeclaredMethods() 返回该类中的所有的方法数组（不分public和非public属性） 示例 获得类中属性相关的方法 方法 含义 getField(String name) 根据变量名，返回一个具体的具有public属性的成员变量 getFields() 返回具有public属性的成员变量的数组 getDeclaredField(String name) 根据变量名，返回一个成员变量（不分public和非public属性） getDeclaredFields() 返回所有成员变量组成的数组（不分public和非public属性） 示例 获得类中注解相关的方法 方法 含义 getAnnotation(Class annotationClass) 返回该类中与参数类型匹配的公有注解对象 getAnnotations() 返回该类所有的公有注解对象 getDeclaredAnnotation(Class annotationClass) 返回该类中与参数类型匹配的直接修饰的所有注解对象 getDeclaredAnnotations() 返回该类所有的直接修饰的注解对象 示例 其他重要的方法 方法 含义 isAnnotation() 判断是否是注解 isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) 判断是否是指定类型的注解 isAnonymousClass() 判断是否是匿名类 isArray() 判断是否是数组类 isEnum() 判断是否是枚举类 isInstance(Object obj) 判断obj是否是该类的实例 isInterface() 判断是否是接口类 Field类Field代表类的成员变量（属性） 方法 含义 get(Object obj) 获取obj对应的属性值 set(Object obj,Object value) 设置obj对应的属性值 equals(Object obj) 判断与obj是否相等 Method类Method代表类的方法 方法 含义 invoke(Object receiver,Object… args) 传递object对象及参数调用该对象对应的方法 参数receiver指明了调用对象，参数args指明该方法所需要接收的参数。由于是运行时动态的调用类的方法，无法提前知道参数类型和返回值，所以传入和返回的都是Object比如： 1234567891011class MyTest&#123; private int testInvoke(int i)&#123; return i*10; &#125;&#125;Class&lt;?&gt; classTest = Class.forName(\"com.zwb.MyTest\");Method methodTest = MyTest.getDeclaredMethod(\"testInvoke\",int.class);methodTest.setAccessible(true);Object objectTest = classTest.newInstance();int result = (int) methodTest.invoke(objectTest,1);// result=10 说明这里主要是学习反射最基础的语法和相关的API，一些深层的知识点请自行查阅资料。以上都是参考别人总结的（绝不是copy，都是在理解的基础上一字一句自己敲的），示例是我根据相关的API自己敲的，古人云：眼过千遍不如手过一遍。如对原文作者又冒犯之处，请及时联系立删 参考：https://www.jianshu.com/p/9be58ee20deehttps://www.cnblogs.com/crazypebble/archive/2011/04/13/2014582.html","categories":[{"name":"技术","slug":"技术","permalink":"http://www.wblog.work/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"http://www.wblog.work/categories/技术/Java/"},{"name":"反射和注解","slug":"技术/Java/反射和注解","permalink":"http://www.wblog.work/categories/技术/Java/反射和注解/"}],"tags":[{"name":"反射","slug":"反射","permalink":"http://www.wblog.work/tags/反射/"}]}]}